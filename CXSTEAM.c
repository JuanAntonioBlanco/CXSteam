#include <math.h>
#include <stdio.h>
#include "CXSTEAM.h"



// Constants for the calculation of water steam properties

const double SPECIFIC_GAS_CONSTANT = 0.461526;  // kJ kg^-1 K^-1
const double CRITICAL_TEMPERATURE = 647.096;  // K
const double CRITICAL_PRESSURE = 22.06395;  // MPa
const double CRITICAL_DENSITY = 322.0;  // kg m^-1
const double TRIPLE_POINT_TEMPERATURE = 273.16;  // K
const double TRIPLE_POINT_PRESSURE = 0.000611657;  // MPa
const double TRIPLE_POINT_SPECIFIC_ENTHALPY = 0.611783e-3;  // kJ kg^-1
const double CRITICAL_TEMPERATURE_H20_1992 = 647.096;  // +-0.1 K
const double CRITICAL_PRESSURE_H20_1992 = 22.067;  // + 0.27*(+-0.1)+-0.005 MPa
const double CRITICAL_DENSITY_H20_1992 = 322.0;  // +-3 kg m^-1
const double CRITICAL_TEMPERATURE_D20_1992 = 643.847;  // +-0.2 K
const double CRITICAL_PRESSURE_D20_1992 = 21.671;  // + 0.27*(+-0.2)+-0.01 MPa
const double CRITICAL_DENSITY_D20_1992 = 356.0;  // +-5 kg m^-1
const double ABSOLUTE_ZERO_CELSIUS = -273.15;  // °C
const double ABSOLUTE_ZERO_FAHRENHEIT = -459.67;  // °F
const double SPECIFIC_GAS_CONSTANT_IAPWS_R15_11 = 0.46151805;  // kJ kg^-1 K^-1
const double CRITICAL_TEMPERATURE_IAPWS_R15_11 = 647.096;  // K
const double CRITICAL_DENSITY_IAPWS_R15_11 = 322.0;  // kg m^-1


//Aqui va la parte correspondiente a IAPWS_R14

#define TYPE_ICE_Ih 1
#define TYPE_ICE_III 3
#define TYPE_ICE_V 5
#define TYPE_ICE_VI 6
#define TYPE_ICE_VII 7

double pmelt_T_iceIh(double T) {
    double T_star = 273.16;
    double p_star = 611.657e-6;
    double theta = T / T_star;
    double a[] = {0.119539337e7, 0.808183159e5, 0.333826860e4};
    double b[] = {0.300000e1, 0.257500e2, 0.103750e3};
    double temp_sum = 0;
    for (int i = 0; i < 3; i++) {
        temp_sum += a[i] * (1 - pow(theta, b[i]));
    }
    double pi_melt = 1 + temp_sum;
    return pi_melt * p_star;
}

double pmelt_T_iceIII(double T) {
    double T_star = 251.165;
    double p_star = 208.566;
    double theta = T / T_star;
    double pi_melt = 1 - 0.299948 * (1.0 - pow(theta, 60));
    return pi_melt * p_star;
}

double pmelt_T_iceV(double T) {
    double T_star = 256.164;
    double p_star = 350.1;
    double theta = T / T_star;
    double pi_melt = 1 - 1.18721 * (1.0 - pow(theta, 8));
    return pi_melt * p_star;
}

double pmelt_T_iceVI(double T) {
    double T_star = 273.31;
    double p_star = 632.4;
    double theta = T / T_star;
    double pi_melt = 1 - 1.07476 * (1.0 - pow(theta, 4.6));
    return pi_melt * p_star;
}

double pmelt_T_iceVII(double T) {
    double T_star = 355.0;
    double p_star = 2216.0;
    double theta = T / T_star;
    double p1 = 0.173683e1 * (1 - pow(theta, -1));
    double p2 = 0.544606e-1 * (1 - pow(theta, 5));
    double p3 = 0.806106e-7 * (1 - pow(theta, 22));
    double pi_melt = exp(p1 - p2 + p3);
    return pi_melt * p_star;
}

double psubl_T(double T) {
    double T_star = 273.16;
    double p_star = 611.657e-6;
    double a[] = {-0.212144006e2, 0.273203819e2, -0.610598130e1};
    double b[] = {0.333333333e-2, 0.120666667e1, 0.170333333e1};
    double theta = T / T_star;
    double temp_sum = 0;
    for (int i = 0; i < 3; i++) {
        temp_sum += a[i] * pow(theta, b[i]);
    }
    double pi_subl = exp((1 / theta) * temp_sum);
    return pi_subl * p_star;
}




// REGION BORDERS

double B23p_T(double T) {
    return 348.05185628969 - 1.1671859879975 * T + 1.0192970039326e-03 * pow(T, 2);
}

double B23T_p(double p) {
    return 572.54459862746 + sqrt((p - 13.91883977887) / 1.0192970039326e-03);
}

double p3sat_h(double h) {
    int Ii[] = {0, 1, 1, 1, 1, 5, 7, 8, 14, 20, 22, 24, 28, 36};
    int Ji[] = {0, 1, 3, 4, 36, 3, 0, 24, 16, 16, 3, 18, 8, 24};
    double ni[] = {
        0.600073641753024,
        -9.36203654849857,
        24.6590798594147,
        -107.014222858224,
        -91582131580576.8,
        -8623.32011700662,
        -23.5837344740032,
        2.52304969384128e17,
        -3.89718771997719e18,
        -3.33775713645296e22,
        35649946963.6328,
        -1.48547544720641e26,
        3.30611514838798e18,
        8.13641294467829e37
    };
    double hs = h / 2600;
    double ps = 0;
    for (int i = 0; i < 14; i++) {
        ps += ni[i] * pow(hs - 1.02, Ii[i]) * pow(hs - 0.608, Ji[i]);
    }
    return ps * 22;
}

double p3sat_s(double s) {
    int Ii[] = {0, 1, 1, 4, 12, 12, 16, 24, 28, 32};
    int Ji[] = {0, 1, 32, 7, 4, 14, 36, 10, 0, 18};
    double ni[] = {
        0.639767553612785,
        -12.9727445396014,
        -2.24595125848403e15,
        1774667.41801846,
        7170793495.71538,
        -3.78829107169011e17,
        -9.55586736431328e34,
        1.87269814676188e23,
        119254746466.473,
        1.10649277244882e36
    };
    double Sigma = s / 5.2;
    double Pi = 0;
    for (int i = 0; i < 10; i++) {
        Pi += ni[i] * pow(Sigma - 1.03, Ii[i]) * pow(Sigma - 0.699, Ji[i]);
    }
    return Pi * 22;
}

double hB13_s(double s) {
    int Ii[] = {0, 1, 1, 3, 5, 6};
    int Ji[] = {0, -2, 2, -12, -4, -3};
    double ni[] = {
        0.913965547600543,
        -4.30944856041991e-05,
        60.3235694765419,
        1.17518273082168e-18,
        0.220000904781292,
        -69.0815545851641
    };
    double Sigma = s / 3.8;
    double eta = 0;
    for (int i = 0; i < 6; i++) {
        eta += ni[i] * pow(Sigma - 0.884, Ii[i]) * pow(Sigma - 0.864, Ji[i]);
    }
    return eta * 1700;
}

double TB23_hs(double h, double s) {
    int Ii[] = {-12, -10, -8, -4, -3, -2, -2, -2, -2, 0, 1, 1, 1, 3, 3, 5, 6, 6, 8, 8, 8, 12, 12, 14, 14};
    int Ji[] = {10, 8, 3, 4, 3, -6, 2, 3, 4, 0, -3, -2, 10, -2, -1, -5, -6, -3, -8, -2, -1, -12, -1, -12, 1};
    double ni[] = {
        6.2909626082981e-04, -8.23453502583165e-04, 5.15446951519474e-08, -1.17565945784945, 3.48519684726192,
        -5.07837382408313e-12, -2.84637670005479, -2.36092263939673, 6.01492324973779, 1.48039650824546,
        3.60075182221907e-04, -1.26700045009952e-02, -1221843.32521413, 0.149276502463272, 0.698733471798484,
        -2.52207040114321e-02, 1.47151930985213e-02, -1.08618917681849, -9.36875039816322e-04, 81.9877897570217,
        -182.041861521835, 2.61907376402688e-06, -29162.6417025961, 1.40660774926165e-05, 7832370.62349385
    };
    double Sigma = s / 5.3;
    double eta = h / 3000;
    double teta = 0;
    for (int i = 0; i < 25; i++) {
        teta += ni[i] * pow(eta - 0.727, Ii[i]) * pow(Sigma - 0.864, Ji[i]);
    }
    return teta * 900;
}



//Desde aquí es la zona de REGIONS recorda que tenes que incluir la parte de selección y adaptación de esta zona del codigo


double v1_pT(double p, double T) {
    int I1[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31, 32};
    int J1[] = {-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41};
    double n1[] = {
        0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
        0.15772038513228, -0.016616417199501, 8.1214629983568e-04, 2.8319080123804e-04, -6.0706301565874e-04,
        -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993e-05, -4.7184321073267e-04,
        -3.0001780793026e-04, 4.7661393906987e-05, -4.4141845330846e-06, -7.2694996297594e-16, -3.1679644845054e-05,
        -2.8270797985312e-06, -8.5205128120103e-10, -2.2425281908e-06, -6.5171222895601e-07, -1.4341729937924e-13,
        -4.0516996860117e-07, -1.2734301741641e-09, -1.7424871230634e-10, -6.8762131295531e-19, 1.4478307828521e-20,
        2.6335781662795e-23, -1.1947622640071e-23, 1.8228094581404e-24, -9.3537087292458e-26
    };
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p / 16.53;  // 16.53 MPa
    double tau = 1386 / T;  // 1386 K
    double gamma_der_pi = 0;
    for (int i = 0; i < 34; i++) {
        gamma_der_pi += - n1[i] * I1[i] * pow(7.1 - Pi, I1[i] - 1) * pow(tau - 1.222, J1[i]);
    }
    return R * T / p * Pi * gamma_der_pi/1000;
}

double h1_pT(double p, double T) {
    int I1[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31, 32};
    int J1[] = {-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41};
    double n1[] = {
        0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
        0.15772038513228, -0.016616417199501, 8.1214629983568e-04, 2.8319080123804e-04, -6.0706301565874e-04,
        -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993e-05, -4.7184321073267e-04,
        -3.0001780793026e-04, 4.7661393906987e-05, -4.4141845330846e-06, -7.2694996297594e-16, -3.1679644845054e-05,
        -2.8270797985312e-06, -8.5205128120103e-10, -2.2425281908e-06, -6.5171222895601e-07, -1.4341729937924e-13,
        -4.0516996860117e-07, -1.2734301741641e-09, -1.7424871230634e-10, -6.8762131295531e-19, 1.4478307828521e-20,
        2.6335781662795e-23, -1.1947622640071e-23, 1.8228094581404e-24, -9.3537087292458e-26
    };
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p / 16.53;
    double tau = 1386 / T;
    double gamma_der_tau = 0;
    for (int i = 0; i < 34; i++) {
        gamma_der_tau += n1[i] * pow(7.1 - Pi, I1[i]) * J1[i] * pow(tau - 1.222, J1[i] - 1);
    }
    return R * T * tau * gamma_der_tau;
}

double u1_pT(double p, double T) {
    int I1[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31, 32};
    int J1[] = {-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41};
    double n1[] = {
        0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
        0.15772038513228, -0.016616417199501, 8.1214629983568e-04, 2.8319080123804e-04, -6.0706301565874e-04,
        -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993e-05, -4.7184321073267e-04,
        -3.0001780793026e-04, 4.7661393906987e-05, -4.4141845330846e-06, -7.2694996297594e-16, -3.1679644845054e-05,
        -2.8270797985312e-06, -8.5205128120103e-10, -2.2425281908e-06, -6.5171222895601e-07, -1.4341729937924e-13,
        -4.0516996860117e-07, -1.2734301741641e-09, -1.7424871230634e-10, -6.8762131295531e-19, 1.4478307828521e-20,
        2.6335781662795e-23, -1.1947622640071e-23, 1.8228094581404e-24, -9.3537087292458e-26
    };
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p / 16.53;
    double tau = 1386 / T;
    double gamma_der_tau = 0;
    double gamma_der_pi = 0;
    for (int i = 0; i < 34; i++) {
        gamma_der_pi -= n1[i] * I1[i] * pow(7.1 - Pi, I1[i] - 1) * pow(tau - 1.222, J1[i]);
        gamma_der_tau += n1[i] * pow(7.1 - Pi, I1[i]) * J1[i] * pow(tau - 1.222, J1[i] - 1);
    }
    return R * T * (tau * gamma_der_tau - Pi * gamma_der_pi);
}

double s1_pT(double p, double T) {
    double I1[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31, 32
    };
    double J1[] = {
        -2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41
    };
    double n1[] = {
        0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872, 0.15772038513228, -0.016616417199501, 8.1214629983568e-04, 2.8319080123804e-04, -6.0706301565874e-04, -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993e-05, -4.7184321073267e-04, -3.0001780793026e-04, 4.7661393906987e-05, -4.4141845330846e-06, -7.2694996297594e-16, -3.1679644845054e-05, -2.8270797985312e-06, -8.5205128120103e-10, -2.2425281908e-06, -6.5171222895601e-07, -1.4341729937924e-13, -4.0516996860117e-07, -1.2734301741641e-09, -1.7424871230634e-10, -6.8762131295531e-19, 1.4478307828521e-20, 2.6335781662795e-23, -1.1947622640071e-23, 1.8228094581404e-24, -9.3537087292458e-26
    };
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p / 16.53;
    double tau = 1386 / T;
    double gamma = 0;
    double gamma_der_tau = 0;
    for (int i = 0; i < 34; i++) {
        gamma_der_tau += n1[i] * pow(7.1 - Pi, I1[i]) * J1[i] * pow(tau - 1.222, J1[i] - 1);
        gamma += n1[i] * pow(7.1 - Pi, I1[i]) * pow(tau - 1.222, J1[i]);
    }
    return R * tau * gamma_der_tau - R * gamma;
}

double Cp1_pT(double p, double T) {
    double I1[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31, 32
    };
    double J1[] = {
        -2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41
    };
    double n1[] = {
        0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872, 0.15772038513228, -0.016616417199501, 8.1214629983568e-04, 2.8319080123804e-04, -6.0706301565874e-04, -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993e-05, -4.7184321073267e-04, -3.0001780793026e-04, 4.7661393906987e-05, -4.4141845330846e-06, -7.2694996297594e-16, -3.1679644845054e-05, -2.8270797985312e-06, -8.5205128120103e-10, -2.2425281908e-06, -6.5171222895601e-07, -1.4341729937924e-13, -4.0516996860117e-07, -1.2734301741641e-09, -1.7424871230634e-10, -6.8762131295531e-19, 1.4478307828521e-20, 2.6335781662795e-23, -1.1947622640071e-23, 1.8228094581404e-24, -9.3537087292458e-26
    };
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p / 16.53;
    double tau = 1386 / T;
    double gamma_der_tautau = 0;
    for (int i = 0; i < 34; i++) {
        gamma_der_tautau += n1[i] * pow(7.1 - Pi, I1[i]) * J1[i] * (J1[i] - 1) * pow(tau - 1.222, J1[i] - 2);
    }
    return -R * pow(tau, 2) * gamma_der_tautau;
}

double Cv1_pT(double p, double T) {
    int I1[34] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31, 32};
    int J1[34] = {-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41};
    double n1[34] = {0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872, 0.15772038513228, -0.016616417199501, 8.1214629983568e-04, 2.8319080123804e-04, -6.0706301565874e-04, -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993e-05, -4.7184321073267e-04, -3.0001780793026e-04, 4.7661393906987e-05, -4.4141845330846e-06, -7.2694996297594e-16, -3.1679644845054e-05, -2.8270797985312e-06, -8.5205128120103e-10, -2.2425281908e-06, -6.5171222895601e-07, -1.4341729937924e-13, -4.0516996860117e-07, -1.2734301741641e-09, -1.7424871230634e-10, -6.8762131295531e-19, 1.4478307828521e-20, 2.6335781662795e-23, -1.1947622640071e-23, 1.8228094581404e-24, -9.3537087292458e-26};
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p / 16.53;
    double tau = 1386 / T;
    double gamma_der_pi = 0;
    double gamma_der_pipi = 0;
    double gamma_der_pitau = 0;
    double gamma_der_tautau = 0;
    for (int i = 0; i < 34; i++) {
        gamma_der_pi = gamma_der_pi - n1[i] * I1[i] * pow(7.1 - Pi, I1[i] - 1) * pow(tau - 1.222, J1[i]);
        gamma_der_pipi = gamma_der_pipi + n1[i] * I1[i] * (I1[i] - 1) * pow(7.1 - Pi, I1[i] - 2) * pow(tau - 1.222, J1[i]);
        gamma_der_pitau = gamma_der_pitau - n1[i] * I1[i] * pow(7.1 - Pi, I1[i] - 1) * J1[i] * pow(tau - 1.222, J1[i] - 1);
        gamma_der_tautau = gamma_der_tautau + n1[i] * pow(7.1 - Pi, I1[i]) * J1[i] * (J1[i] - 1) * pow(tau - 1.222, J1[i] - 2);
    }
    return R * (-(pow(tau, 2)) * gamma_der_tautau + pow(gamma_der_pi - tau * gamma_der_pitau, 2) / gamma_der_pipi);
}

double w1_pT(double p, double T) {
    int I1[34] = {
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8,
        21, 23, 29, 30, 31, 32
    };
    int J1[34] = {
        -2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10,
        -8, -11, -6, -29, -31, -38, -39, -40, -41
    };
    double n1[34] = {
        0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
        0.15772038513228, -0.016616417199501, 8.1214629983568e-04, 2.8319080123804e-04,
        -6.0706301565874e-04, -0.018990068218419, -0.032529748770505, -0.021841717175414,
        -5.283835796993e-05, -4.7184321073267e-04, -3.0001780793026e-04, 4.7661393906987e-05,
        -4.4141845330846e-06, -7.2694996297594e-16, -3.1679644845054e-05, -2.8270797985312e-06,
        -8.5205128120103e-10, -2.2425281908e-06, -6.5171222895601e-07, -1.4341729937924e-13,
        -4.0516996860117e-07, -1.2734301741641e-09, -1.7424871230634e-10, -6.8762131295531e-19,
        1.4478307828521e-20, 2.6335781662795e-23, -1.1947622640071e-23, 1.8228094581404e-24,
        -9.3537087292458e-26
    };
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p / 16.53;
    double tau = 1386 / T;
    double gamma_der_pi = 0;
    double gamma_der_pipi = 0;
    double gamma_der_pitau = 0;
    double gamma_der_tautau = 0;
    for (int i = 0; i < 34; i++) {
        gamma_der_pi = gamma_der_pi - n1[i] * I1[i] * pow(7.1 - Pi, I1[i] - 1) * pow(tau - 1.222, J1[i]);
        gamma_der_pipi = gamma_der_pipi + n1[i] * I1[i] * (I1[i] - 1) * pow(7.1 - Pi, I1[i] - 2) * pow(tau - 1.222, J1[i]);
        gamma_der_pitau = gamma_der_pitau - n1[i] * I1[i] * pow(7.1 - Pi, I1[i] - 1) * J1[i] * pow(tau - 1.222, J1[i] - 1);
        gamma_der_tautau = gamma_der_tautau + n1[i] * pow(7.1 - Pi, I1[i]) * J1[i] * (J1[i] - 1) * pow(tau - 1.222, J1[i] - 2);
    }

    return sqrt( 1000 * R * T * pow(gamma_der_pi, 2) /
                (((gamma_der_pi - tau * gamma_der_pitau) * (gamma_der_pi - tau * gamma_der_pitau))
                 / (tau * tau * gamma_der_tautau) - gamma_der_pipi));
}

double T1_ph(double p, double h) {
    int I1[] = {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 3, 4, 5, 6};
    int J1[] = {0, 1, 2, 6, 22, 32, 0, 1, 2, 3, 4, 10, 32, 10, 32, 10, 32, 32, 32, 32};
    double n1[] = { -238.72489924521, 404.21188637945, 113.49746881718, -5.8457616048039, -1.528548241314e-04,
    -1.0866707695377e-06, -13.391744872602, 43.211039183559, -54.010067170506, 30.535892203916, -6.5964749423638,
     9.3965400878363e-03, 1.157364750534e-07, -2.5858641282073e-05, -4.0644363084799e-09, 6.6456186191635e-08,
     8.0670734103027e-11, -9.3477771213947e-13, 5.8265442020601e-15, -1.5020185953503e-17 };

    double Pi = p / 1;
    double eta = h / 2500;
    double T = 0;
    for (int i = 0; i < 20; i++) {
        T += n1[i] * pow(Pi, I1[i]) * pow(eta + 1, J1[i]);
    }
    return T;
}

double T1_ps(double p, double s) {
    int I1[] = {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 4};
    int J1[] = {0, 1, 2, 3, 11, 31, 0, 1, 2, 3, 12, 31, 0, 1, 2, 9, 31, 10, 32, 32};
    double n1[] = {
        174.78268058307, 34.806930892873, 6.5292584978455, 0.33039981775489, -1.9281382923196e-07, -2.4909197244573e-23,
        -0.26107636489332, 0.22592965981586, -0.064256463395226, 7.8876289270526e-03, 3.5672110607366e-10, 1.7332496994895e-24,
        5.6608900654837e-04, -3.2635483139717e-04, 4.4778286690632e-05, -5.1322156908507e-10, -4.2522657042207e-26,
        2.6400441360689e-13, 7.8124600459723e-29, -3.0732199903668e-31
    };
    double Pi = p / 1;
    double Sigma = s / 1;
    double T = 0;
    for (int i = 0; i < 20; i++) {
        T += n1[i] * pow(Pi, I1[i]) * pow(Sigma + 2, J1[i]);
    }
    return T;
}

double p1_hs(double h, double s) {
    int I1[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 4, 4, 5};
    int J1[] = {0, 1, 2, 4, 5, 6, 8, 14, 0, 1, 4, 6, 0, 1, 10, 4, 1, 4, 0};
    double n1[] = {
        -0.691997014660582, -18.361254878756, -9.28332409297335, 65.9639569909906, -16.2060388912024,
        450.620017338667, 854.68067822417, 6075.23214001162, 32.6487682621856, -26.9408844582931,
        -319.9478483343, -928.35430704332, 30.3634537455249, -65.0540422444146, -4309.9131651613,
        -747.512324096068, 730.000345529245, 1142.84032569021, -436.407041874559 };

    double eta = h / 3400;
    double Sigma = s / 7.6;
    double p = 0;
    for (int i = 0; i < 19; i++) {
        p += n1[i] * pow(eta + 0.05, I1[i]) * pow(Sigma + 0.05, J1[i]);
    }
    return p * 100;
}

double T1_prho(double p, double rho) {
    double Low_Bound = 273.15;
    double High_Bound = T4_p(p);
    double rhos = -1000;
    int step_counter = 0;
    double Ts = 0;

    while (fabs(rho - rhos) > 0.00001) {
        step_counter++;
        double last_rhos = rhos;

        Ts = (Low_Bound + High_Bound) / 2;
        rhos = 1 / v1_pT(p, Ts);

        if (last_rhos == rhos) {
            printf("T1_prho stopped iterating after %d steps because values did not converge\n", step_counter);
            break;
        }

        if (rhos < rho) {
            High_Bound = Ts;
        }
        else {
            Low_Bound = Ts;
        }
    }
    return Ts;
}

double v2_pT(double p, double T) {
    int Ir[] = {
        1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20, 20, 20, 21, 22, 23, 24, 24, 24
    };
    int Jr[] = {
        0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58
    };
    double nr[] = {
            -1.7731742473213e-03,
            -0.017834862292358,
            -0.045996013696365,
            -0.057581259083432,
            -0.05032527872793,
            -3.3032641670203e-05,
            -1.8948987516315e-04,
            -3.9392777243355e-03,
            -0.043797295650573,
            -2.6674547914087e-05,
            2.0481737692309e-08,
            4.3870667284435e-07,
            -3.227767723857e-05,
            -1.5033924542148e-03,
            -0.040668253562649,
            -7.8847309559367e-10,
            1.2790717852285e-08,
            4.8225372718507e-07,
            2.2922076337661e-06,
            -1.6714766451061e-11,
            -2.1171472321355e-03,
            -23.895741934104,
            -5.905956432427e-18,
            -1.2621808899101e-06,
            -0.038946842435739,
            1.1256211360459e-11,
            -8.2311340897998,
            1.9809712802088e-08,
            1.0406965210174e-19,
            -1.0234747095929e-13,
            -1.0018179379511e-09,
            -8.0882908646985e-11,
            0.10693031879409,
            -0.33662250574171,
            8.9185845355421e-25,
            3.0629316876232e-13,
            -4.2002467698208e-06,
            -5.9056029685639e-26,
            3.7826947613457e-06,
            -1.2768608934681e-15,
            7.3087610595061e-29,
            5.5414715350778e-17,
            -9.436970724121e-07
    };
        double R = SPECIFIC_GAS_CONSTANT;
        double Pi = p;
        double tau = 540 / T;
        double g0_pi = 1 / Pi;
        double gr_pi = 0;
        for (int i = 0; i < 43; i++) {
            gr_pi = gr_pi + nr[i] * Ir[i] * pow(Pi,(Ir[i] - 1)) * pow((tau - 0.5),Jr[i]);
        }
        return R * T/ p * Pi * (g0_pi + gr_pi) / 1000;
}

double h2_pT(double p, double T){
        // function h2_pT = h2_pT(p, T)

        // Equations for Region 2, Section. 6.1 Basic Equation

        // Table 11 and 12, Page 14 and 15

        int J0[] = {0, 1, -5, -4, -3, -2, -1, 2, 3};
        double n0[] = {
            -9.6927686500217,
            10.086655968018,
            -0.005608791128302,
            0.071452738081455,
            -0.40710498223928,
            1.4240819171444,
            -4.383951131945,
            -0.28408632460772,
            0.021268463753307,
        };
        int Ir[] = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18,
            20, 20, 20, 21, 22, 23, 24, 24, 24};
        int Jr[] = { 0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29,
            50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58 };
        double nr[] = {
            -1.7731742473213e-03,
            -0.017834862292358,
            -0.045996013696365,
            -0.057581259083432,
            -0.05032527872793,
            -3.3032641670203e-05,
            -1.8948987516315e-04,
            -3.9392777243355e-03,
            -0.043797295650573,
            -2.6674547914087e-05,
            2.0481737692309e-08,
            4.3870667284435e-07,
            -3.227767723857e-05,
            -1.5033924542148e-03,
            -0.040668253562649,
            -7.8847309559367e-10,
            1.2790717852285e-08,
            4.8225372718507e-07,
            2.2922076337661e-06,
            -1.6714766451061e-11,
            -2.1171472321355e-03,
            -23.895741934104,
            -5.905956432427e-18,
            -1.2621808899101e-06,
            -0.038946842435739,
            1.1256211360459e-11,
            -8.2311340897998,
            1.9809712802088e-08,
            1.0406965210174e-19,
            -1.0234747095929e-13,
            -1.0018179379511e-09,
            -8.0882908646985e-11,
            0.10693031879409,
            -0.33662250574171,
            8.9185845355421e-25,
            3.0629316876232e-13,
            -4.2002467698208e-06,
            -5.9056029685639e-26,
            3.7826947613457e-06,
            -1.2768608934681e-15,
            7.3087610595061e-29,
            5.5414715350778e-17,
            -9.436970724121e-07};
        double R = SPECIFIC_GAS_CONSTANT;
        double Pi = p;
        double tau = 540 / T;
        double g0_tau = 0;
        double gr_tau = 0;
        for (int i = 0; i < 9; i++) {
            g0_tau += n0[i] * J0[i] * pow(tau , (J0[i] - 1));
        }

        for (int i = 0; i < 43 ; i++){
            gr_tau += nr[i] * pow(Pi , Ir[i]) * Jr[i] * pow((tau - 0.5) , (Jr[i] - 1));
        }
        return R * T * tau * (g0_tau + gr_tau);
}

double u2_pT(double p, double T) {
    int J0[] = {0, 1, -5, -4, -3, -2, -1, 2, 3};
    double n0[] = {-9.6927686500217, 10.086655968018, -0.005608791128302, 0.071452738081455, -0.40710498223928, 1.4240819171444, -4.383951131945, -0.28408632460772, 0.021268463753307};
    int Ir[] = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20, 20, 20, 21, 22, 23, 24, 24, 24};
    int Jr[] = {0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58};
    double nr[] = {-1.7731742473213e-03,
               -0.017834862292358,
               -0.045996013696365,
               -0.057581259083432,
               -0.05032527872793,
               -3.3032641670203e-05,
               -1.8948987516315e-04,
               -3.9392777243355e-03,
               -0.043797295650573,
               -2.6674547914087e-05,
               2.0481737692309e-08,
               4.3870667284435e-07,
               -3.227767723857e-05,
               -1.5033924542148e-03,
               -0.040668253562649,
               -7.8847309559367e-10,
               1.2790717852285e-08,
               4.8225372718507e-07,
               2.2922076337661e-06,
               -1.6714766451061e-11,
               -2.1171472321355e-03,
               -23.895741934104,
               -5.905956432427e-18,
               -1.2621808899101e-06,
               -0.038946842435739,
               1.1256211360459e-11,
               -8.2311340897998,
               1.9809712802088e-08,
               1.0406965210174e-19,
               -1.0234747095929e-13,
               -1.0018179379511e-09,
               -8.0882908646985e-11,
               0.10693031879409,
               -0.33662250574171,
               8.9185845355421e-25,
               3.0629316876232e-13,
               -4.2002467698208e-06,
               -5.9056029685639e-26,
               3.7826947613457e-06,
               -1.2768608934681e-15,
               7.3087610595061e-29,
               5.5414715350778e-17,
               -9.436970724121e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p;
    double tau = 540 / T;
    double g0_pi = 1 / Pi;
    double g0_tau = 0;

    for (int i = 0; i < 9; i++) {
        g0_tau += n0[i] * J0[i] * pow(tau, J0[i] - 1);
    }

    double gr_pi = 0;
    double gr_tau = 0;

    for (int i = 0; i < 43; i++) {
        gr_pi += nr[i] * Ir[i] * pow(Pi, Ir[i] - 1) * pow(tau - 0.5, Jr[i]);
        gr_tau += nr[i] * pow(Pi, Ir[i]) * Jr[i] * pow(tau - 0.5, Jr[i] - 1);
    }

    return R * T * (tau * (g0_tau + gr_tau) - Pi * (g0_pi + gr_pi));
}

double s2_pT(double p, double T) {
    int J0[] = {0, 1, -5, -4, -3, -2, -1, 2, 3};
    double n0[] = {-9.6927686500217, 10.086655968018, -0.005608791128302, 0.071452738081455, -0.40710498223928, 1.4240819171444,
    -4.383951131945, -0.28408632460772, 0.021268463753307};
    int Ir[] = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20,
    20, 20, 21, 22, 23, 24, 24, 24};
    int Jr[] = {0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50,
    57, 20, 35, 48, 21, 53, 39, 26, 40, 58};
    double nr[] = {
    -1.7731742473213e-03,
    -0.017834862292358,
    -0.045996013696365,
    -0.057581259083432,
    -0.05032527872793,
    -3.3032641670203e-05,
    -1.8948987516315e-04,
    -3.9392777243355e-03,
    -0.043797295650573,
    -2.6674547914087e-05,
    2.0481737692309e-08,
    4.3870667284435e-07,
    -3.227767723857e-05,
    -1.5033924542148e-03,
    -0.040668253562649,
    -7.8847309559367e-10,
    1.2790717852285e-08,
    4.8225372718507e-07,
    2.2922076337661e-06,
    -1.6714766451061e-11,
    -2.1171472321355e-03,
    -23.895741934104,
    -5.905956432427e-18,
    -1.2621808899101e-06,
    -0.038946842435739,
    1.1256211360459e-11,
    -8.2311340897998,
    1.9809712802088e-08,
    1.0406965210174e-19,
    -1.0234747095929e-13,
    -1.0018179379511e-09,
    -8.0882908646985e-11,
    0.10693031879409,
    -0.33662250574171,
    8.9185845355421e-25,
    3.0629316876232e-13,
    -4.2002467698208e-06,
    -5.9056029685639e-26,
    3.7826947613457e-06,
    -1.2768608934681e-15,
    7.3087610595061e-29,
    5.5414715350778e-17,
    -9.436970724121e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p;
    double tau = 540.0 / T;
    double g0 = log(Pi);
    double g0_tau = 0;

    for (int i = 0; i < 9; i++) {
        g0 = g0 + n0[i] * pow(tau, J0[i]);
        g0_tau = g0_tau + n0[i] * J0[i] * pow(tau, J0[i] - 1);
    }

    double gr = 0;
    double gr_tau = 0;

    for (int i = 0; i < 43; i++) {
        gr = gr + nr[i] * pow(Pi, Ir[i]) * pow((tau - 0.5), Jr[i]);
        gr_tau = gr_tau + nr[i] * pow(Pi, Ir[i]) * Jr[i] * pow((tau - 0.5), (Jr[i] - 1));
    }

    return R * (tau * (g0_tau + gr_tau) - (g0 + gr));
}

double Cp2_pT(double p, double T) {
    double J0[] = {0, 1, -5, -4, -3, -2, -1, 2, 3};
    double n0[] = {
        -9.6927686500217,
        10.086655968018,
        -0.005608791128302,
        0.071452738081455,
        -0.40710498223928,
        1.4240819171444,
        -4.383951131945,
        -0.28408632460772,
        0.021268463753307,
    };
    double Ir[] = {
        1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9,
        10, 10, 10, 16, 16, 18, 20, 20, 20, 21, 22, 23, 24, 24, 24,
    };
    double Jr[] = {
        0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36,
        13, 4, 10, 14, 29, 50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58,
    };
    double nr[] = {
        -1.7731742473213e-03,
        -0.017834862292358,
        -0.045996013696365,
        -0.057581259083432,
        -0.05032527872793,
        -3.3032641670203e-05,
        -1.8948987516315e-04,
        -3.9392777243355e-03,
        -0.043797295650573,
        -2.6674547914087e-05,
        2.0481737692309e-08,
        4.3870667284435e-07,
        -3.227767723857e-05,
        -1.5033924542148e-03,
        -0.040668253562649,
        -7.8847309559367e-10,
        1.2790717852285e-08,
        4.8225372718507e-07,
        2.2922076337661e-06,
        -1.6714766451061e-11,
        -2.1171472321355e-03,
        -23.895741934104,
        -5.905956432427e-18,
        -1.2621808899101e-06,
        -0.038946842435739,
        1.1256211360459e-11,
        -8.2311340897998,
        1.9809712802088e-08,
        1.0406965210174e-19,
        -1.0234747095929e-13,
        -1.0018179379511e-09,
        -8.0882908646985e-11,
        0.10693031879409,
        -0.33662250574171,
        8.9185845355421e-25,
        3.0629316876232e-13,
        -4.2002467698208e-06,
        -5.9056029685639e-26,
        3.7826947613457e-06,
        -1.2768608934681e-15,
        7.3087610595061e-29,
        5.5414715350778e-17,
        -9.436970724121e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p;
    double tau = 540 / T;
    double g0_tautau = 0;

    for (int i = 0; i < 9; i++) {
        g0_tautau += n0[i] * J0[i] * (J0[i] - 1) * pow(tau, J0[i] - 2);
    }

    double gr_tautau = 0;

    for (int i = 0; i < 43; i++) {
        gr_tautau += nr[i] * pow(Pi, Ir[i]) * Jr[i] * (Jr[i] - 1) * pow(tau - 0.5, Jr[i] - 2);
    }

    return -R * pow(tau, 2) * (g0_tautau + gr_tautau);
}

double Cv2_pT(double p, double T) {

    double J0[9] = {0, 1, -5, -4, -3, -2, -1, 2, 3};
    double n0[9] = {-9.6927686500217, 10.086655968018, -0.005608791128302, 0.071452738081455, -0.40710498223928, 1.4240819171444, -4.383951131945, -0.28408632460772, 0.021268463753307};
    int Ir[43] = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20, 20, 20, 21, 22, 23, 24, 24, 24};
    int Jr[43] = {0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58};
    double nr[43] = {
            -1.7731742473213e-03,
            -0.017834862292358,
            -0.045996013696365,
            -0.057581259083432,
            -0.05032527872793,
            -3.3032641670203e-05,
            -1.8948987516315e-04,
            -3.9392777243355e-03,
            -0.043797295650573,
            -2.6674547914087e-05,
            2.0481737692309e-08,
            4.3870667284435e-07,
            -3.227767723857e-05,
            -1.5033924542148e-03,
            -0.040668253562649,
            -7.8847309559367e-10,
            1.2790717852285e-08,
            4.8225372718507e-07,
            2.2922076337661e-06,
            -1.6714766451061e-11,
            -2.1171472321355e-03,
            -23.895741934104,
            -5.905956432427e-18,
            -1.2621808899101e-06,
            -0.038946842435739,
            1.1256211360459e-11,
            -8.2311340897998,
            1.9809712802088e-08,
            1.0406965210174e-19,
            -1.0234747095929e-13,
            -1.0018179379511e-09,
            -8.0882908646985e-11,
            0.10693031879409,
            -0.33662250574171,
            8.9185845355421e-25,
            3.0629316876232e-13,
            -4.2002467698208e-06,
            -5.9056029685639e-26,
            3.7826947613457e-06,
            -1.2768608934681e-15,
            7.3087610595061e-29,
            5.5414715350778e-17,
            -9.436970724121e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p;
    double tau = 540 / T;
    double g0_tautau = 0;
    for (int i = 0; i < 9; i++) {
        g0_tautau += n0[i] * J0[i] * (J0[i] - 1) * pow(tau, J0[i] - 2);
    }
    double gr_pi = 0;
    double gr_pitau = 0;
    double gr_pipi = 0;
    double gr_tautau = 0;
    for (int i = 0; i < 43; i++) {
        gr_pi += nr[i] * Ir[i] * pow(Pi, Ir[i] - 1) * pow(tau - 0.5, Jr[i]);
        gr_pipi += nr[i] * Ir[i] * (Ir[i] - 1) * pow(Pi, Ir[i] - 2) * pow(tau - 0.5, Jr[i]);
        gr_pitau += nr[i] * Ir[i] * pow(Pi, Ir[i] - 1) * Jr[i] * pow(tau - 0.5, Jr[i] - 1);
        gr_tautau += nr[i] * pow(Pi, Ir[i]) * Jr[i] * (Jr[i] - 1) * pow(tau - 0.5, Jr[i] - 2);
    }

    return R * (-(pow(tau, 2)) * (g0_tautau + gr_tautau) - pow(1 + Pi * gr_pi - tau * Pi * gr_pitau, 2) / (1 - pow(Pi, 2) * gr_pipi));
}

double w2_pT(double p, double T) {
    int J0[] = {0, 1, -5, -4, -3, -2, -1, 2, 3};
    double n0[] = {
        -9.6927686500217,
        10.086655968018,
        -0.005608791128302,
        0.071452738081455,
        -0.40710498223928,
        1.4240819171444,
        -4.383951131945,
        -0.28408632460772,
        0.021268463753307
    };
    int Ir[] = {
        1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 4, 4, 4, 5, 6,
        6, 6, 7, 7, 7, 8, 8, 9, 10, 10,
        10, 16, 16, 18, 20, 20, 20, 21, 22,
        23, 24, 24, 24
    };
    int Jr[] = {
        0, 1, 2, 3, 6, 1, 2, 4, 7, 36,
        0, 1, 3, 6, 35, 1, 2, 3, 7, 3,
        16, 35, 0, 11, 25, 8, 36, 13, 4,
        10, 14, 29, 50, 57, 20, 35, 48, 21,
        53, 39, 26, 40, 58
    };
    double nr[] = {
        -1.7731742473213e-03,
        -0.017834862292358,
        -0.045996013696365,
        -0.057581259083432,
        -0.05032527872793,
        -3.3032641670203e-05,
        -1.8948987516315e-04,
        -3.9392777243355e-03,
        -0.043797295650573,
        -2.6674547914087e-05,
        2.0481737692309e-08,
        4.3870667284435e-07,
        -3.227767723857e-05,
        -1.5033924542148e-03,
        -0.040668253562649,
        -7.8847309559367e-10,
        1.2790717852285e-08,
        4.8225372718507e-07,
        2.2922076337661e-06,
        -1.6714766451061e-11,
        -2.1171472321355e-03,
        -23.895741934104,
        -5.905956432427e-18,
        -1.2621808899101e-06,
        -0.038946842435739,
        1.1256211360459e-11,
        -8.2311340897998,
        1.9809712802088e-08,
        1.0406965210174e-19,
        -1.0234747095929e-13,
        -1.0018179379511e-09,
        -8.0882908646985e-11,
        0.10693031879409,
        -0.33662250574171,
        8.9185845355421e-25,
        3.0629316876232e-13,
        -4.2002467698208e-06,
        -5.9056029685639e-26,
        3.7826947613457e-06,
        -1.2768608934681e-15,
        7.3087610595061e-29,
        5.5414715350778e-17,
        -9.436970724121e-07
    };
    double R = SPECIFIC_GAS_CONSTANT;
    double Pi = p;
    double tau = 540 / T;
    double g0_tautau = 0;

    for (int i = 0; i < 9; i++) {
        g0_tautau += n0[i] * J0[i] * (J0[i] - 1) * pow(tau, J0[i] - 2);
    }

    double gr_pi = 0;
    double gr_pitau = 0;
    double gr_pipi = 0;
    double gr_tautau = 0;

    for (int i = 0; i < 43; i++) {
        gr_pi += nr[i] * Ir[i] * pow(Pi, Ir[i] - 1) * pow(tau - 0.5, Jr[i]);
        gr_pipi += nr[i] * Ir[i] * (Ir[i] - 1) * pow(Pi, Ir[i] - 2) * pow(tau - 0.5, Jr[i]);
        gr_pitau += nr[i] * Ir[i] * pow(Pi, Ir[i] - 1) * Jr[i] * pow(tau - 0.5, Jr[i] - 1);
        gr_tautau += nr[i] * pow(Pi, Ir[i]) * Jr[i] * (Jr[i] - 1) * pow(tau - 0.5, Jr[i] - 2);
    }

    double result = sqrt(1000 * R * T * (1 + 2 * Pi * gr_pi + pow(Pi, 2) * pow(gr_pi, 2)) /
                         ((1 - pow(Pi, 2) * gr_pipi) +
                          pow((1 + Pi * gr_pi - tau * Pi * gr_pitau), 2) / (pow(tau, 2) * (g0_tautau + gr_tautau))));

    return result;
}

double T2_ph(double p, double h){
    int sub_reg = 0;
    double Ts;

    if (p < 4) {
        sub_reg = 1;
    }
    else {
        if (p < (905.84278514723 - 0.67955786399241 * h + 1.2809002730136e-04 * pow(h, 2))) {
            sub_reg = 2;
        }
        else {
            sub_reg = 3;
        }
    }

    if (sub_reg == 1) {
    int Ji[] = {0, 1, 2, 3, 7, 20, 0, 1, 2, 3, 7, 9, 11, 18, 44, 0, 2, 7, 36, 38, 40, 42, 44, 24, 44, 12, 32, 44, 32, 36, 42,
        34, 44, 28};
    int Ii[] = {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7};
    double ni[] = {1089.8952318288, 849.51654495535, -107.81748091826, 33.153654801263, -7.4232016790248, 11.765048724356,
        1.844574935579, -4.1792700549624, 6.2478196935812, -17.344563108114, -200.58176862096, 271.96065473796, -455.11318285818,
        3091.9688604755, 252266.40357872, -6.1707422868339e-03, -0.31078046629583, 11.670873077107, 128127984.04046,
        -985549096.23276, 2822454697.3002, -3594897141.0703, 1722734991.3197, -13551.334240775, 12848734.66465, 1.3865724283226,
        235988.32556514, -13105236.545054, 7399.9835474766, -551966.9703006, 3715408.5996233, 19127.72923966, -415351.64835634,
        -62.459855192507};
    Ts = 0;
    double hs = h / 2000.0;
    for (int i = 0; i < 34; i++) {
        Ts = Ts + ni[i] * pow(p, Ii[i]) * pow(hs - 2.1, Ji[i]);
        }
    }
    else {
        if (sub_reg == 2) {
            // Subregion B
            // Table 21, Eq 23, page 23
            int Ji[] = {0, 1, 2, 12, 18, 24, 28, 40, 0, 2, 6, 12, 18, 24, 28, 40, 2, 8, 18, 40, 1, 2, 12, 24, 2, 12, 18, 24, 28, 40,
                18, 24, 40, 28, 2, 28, 1, 40};
            int Ii[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 7, 7,
                9, 9};
            double ni[] = {1489.5041079516, 743.07798314034, -97.708318797837, 2.4742464705674, -0.63281320016026, 1.1385952129658,
                -0.47811863648625, 8.5208123431544e-03, 0.93747147377932, 3.3593118604916, 3.3809355601454, 0.16844539671904,
                0.73875745236695, -0.47128737436186, 0.15020273139707, -0.002176411421975, -0.021810755324761, -0.10829784403677,
                -0.046333324635812, 7.1280351959551e-05, 1.1032831789999e-04, 1.8955248387902e-04, 3.0891541160537e-03,
                1.3555504554949e-03, 2.8640237477456e-07, -1.0779857357512e-05, -7.6462712454814e-05, 1.4052392818316e-05,
                -3.1083814331434e-05, -1.0302738212103e-06, 2.821728163504e-07, 1.2704902271945e-06, 7.3803353468292e-08,
                -1.1030139238909e-08, -8.1456365207833e-14, -2.5180545682962e-11, -1.7565233969407e-18, 8.6934156344163e-15};
            Ts = 0;
            double hs = h / 2000.0;
            for (int i = 0; i < 38; i++) {
                Ts = Ts + ni[i] * pow(p - 2.0, Ii[i]) * pow(hs - 2.6, Ji[i]);
            }
        }
        else {
        // Subregion C
        // Table 22, Eq 24, page 24
        int Ji[] = {0, 4, 0, 2, 0, 2, 0, 1, 0, 2, 0, 1, 4, 8, 4, 0, 1, 4, 10, 12, 16, 20, 22};
        int Ii[] = {-7, -7, -6, -6, -5, -5, -2, -2, -1, -1, 0, 0, 1, 1, 2, 6, 6, 6, 6, 6, 6, 6, 6};
        double ni[] = {-3236839855524.2, 7326335090218.1, 358250899454.47, -583401318515.9, -10783068217.47, 20825544563.171,
        610747.83564516, 859777.2253558, -25745.72360417, 31081.088422714, 1208.2315865936, 482.19755109255, 3.7966001272486,
        -10.842984880077, -0.04536417267666, 1.4559115658698e-13, 1.126159740723e-12, -1.7804982240686e-11, 1.2324579690832e-07,
        -1.1606921130984e-06, 2.7846367088554e-05, -5.9270038474176e-04, 1.2918582991878e-03};
        Ts = 0;
        double hs = h / 2000.0;
        for (int i = 0; i < 23; i++) {
            Ts = Ts + ni[i] * pow(p + 25.0, Ii[i]) * pow(hs - 1.8, Ji[i]);
        }
        }
    }
    return Ts;
}

double T2_ps(double p, double s) {
    int sub_reg;
    double teta = 0;
    if (p < 4) {
        sub_reg = 1;
    }
    else {
        if (s < 5.85) {
            sub_reg = 3;
        } else {
            sub_reg = 2;
        }
    }
    if (sub_reg == 1) {
    // Subregion A
    // Table 25, Eq 25, page 26
    double Ii[] = { -1.5, -1.5, -1.5, -1.5, -1.5, -1.5, -1.25, -1.25, -1.25, -1, -1, -1, -1, -1, -1, -0.75, -0.75, -0.5, -0.5,
        -0.5, -0.5, -0.25, -0.25, -0.25, -0.25, 0.25, 0.25, 0.25, 0.25, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.75, 0.75, 0.75,
        0.75, 1, 1, 1.25, 1.25, 1.5, 1.5,
    };
    int  Ji[] = {
        -24, -23, -19, -13, -11, -10, -19, -15, -6, -26, -21, -17, -16, -9, -8, -15, -14, -26, -13, -9, -7, -27, -25, -11, -6,
        1, 4, 8, 11, 0, 1, 5, 6, 10, 14, 16, 0, 4, 9, 17, 7, 18, 3, 15, 5, 18};
    double ni[] = {
        -392359.83861984, 515265.7382727, 40482.443161048, -321.93790923902, 96.961424218694, -22.867846371773, -449429.14124357,
        -5011.8336020166, 0.35684463560015, 44235.33584819, -13673.388811708, 421632.60207864, 22516.925837475, 474.42144865646,
        -149.31130797647, -197811.26320452, -23554.39947076, -19070.616302076, 55375.669883164, 3829.3691437363, -603.91860580567,
        1936.3102620331, 4266.064369861, -5978.0638872718, -704.01463926862, 338.36784107553, 20.862786635187, 0.033834172656196,
        -4.3124428414893e-05, 166.53791356412, -139.86292055898, -0.78849547999872, 0.072132411753872, -5.9754839398283e-03,
        -1.2141358953904e-05, 2.3227096733871e-07, -10.538463566194, 2.0718925496502, -0.072193155260427, 2.074988708112e-07,
        -0.018340657911379, 2.9036272348696e-07, 0.21037527893619, 2.5681239729999e-04, -0.012799002933781, -8.2198102652018e-06
    };
    double Pi = p;
    double Sigma = s / 2;
    teta = 0;
    for (int i = 0; i < 46; i++) {
        teta = teta + ni[i] * pow(Pi, Ii[i]) * pow((Sigma - 2), Ji[i]);
    }
    }
    else{
        if(sub_reg == 2){
        //Subregion B
        //Table 26, Eq 26, page 27
        int Ii[] = { -6,-6,-5,-5,-4,-4,-4,-3,-3,-3,-3,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,3,3,3,4,
        4,5,5,5};
        int Ji[] = {0,11,0,11,0,1,11,0,1,11,12,0,1,6,10,0,1,5,8,9,0,1,2,4,5,6,9,0,1,2,3,7,8,0,1,5,0,1,3,0,1,0,1,2};
        double ni[] = {316876.65083497,20.864175881858,-398593.99803599,-21.816058518877,223697.85194242,-2784.1703445817,
        9.920743607148,-75197.512299157,2970.8605951158,-3.4406878548526,0.38815564249115,17511.29508575,-1423.7112854449,
        1.0943803364167,0.89971619308495,-3375.9740098958,471.62885818355,-1.9188241993679,0.41078580492196,-0.33465378172097,
        1387.0034777505,-406.63326195838,41.72734715961,2.1932549434532,-1.0320050009077,0.35882943516703,5.2511453726066e-03,
        12.838916450705,-2.8642437219381,0.56912683664855,-0.099962954584931,-3.2632037778459e-03,2.3320922576723e-04,
        -0.1533480985745,0.029072288239902,3.7534702741167e-04,1.7296691702411e-03,-3.8556050844504e-04,-3.5017712292608e-05,
        -1.4566393631492e-05,5.6420857267269e-06,4.1286150074605e-08,-2.0684671118824e-08,1.6409393674725e-09};
        double Pi = p;
        double Sigma = s / 0.7853;
        teta = 0;
        for (int i=0; i<44; i++){
            teta += ni[i] * pow(Pi,Ii[i]) * pow(10 - Sigma,Ji[i]);
        }
        }
    else{
            //Subregion C
            //Table 27, Eq 27, page 28
        int Ii[] = {-2,-2,-1,0,0,0,0,1,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,7,7,7,7,7};
        int Ji[] ={0,1,0,0,1,2,3,0,1,3,4,0,1,2,0,1,5,0,1,4,0,1,2,0,1,0,1,3,4,5};
        double ni[] = {909.68501005365,2404.566708842,-591.6232638713,541.45404128074,-270.98308411192,979.76525097926,
        -469.66772959435,14.399274604723,-19.104204230429,5.3299167111971,-21.252975375934,-0.3114733441376,0.60334840894623,
        -0.042764839702509,5.8185597255259e-03,-0.014597008284753,5.6631175631027e-03,-7.6155864584577e-05,2.2440342919332e-04,
        -1.2561095013413e-05,6.3323132660934e-07,-2.0541989675375e-06,3.6405370390082e-08,-2.9759897789215e-09,
        1.0136618529763e-08,5.9925719692351e-12,-2.0677870105164e-11,-2.0874278181886e-11,1.0162166825089e-10,
        -1.6429828281347e-10};
        double Pi = p;
        double Sigma = s / 2.9251;
        teta = 0;
        for (int i=0;i<30;i++){
            teta += ni[i] * pow(Pi,Ii[i]) * pow(2 - Sigma , Ji[i]);
        }

    }
    }
    return teta;
}

double p2_hs(double h, double s){
    // function p2_hs = p2_hs(h, s)
    // Supplementary Release on Backward Equations for Pressure as a function of Enthalpy and Entropy p(h,s) to the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    // Chapter 6: Backward Equations p(h,s) for Region 2
    double result = 0;
    int sub_reg =0;
    if (h < (-3498.98083432139 + 2575.60716905876 * s - 421.073558227969 * s*s
        + 27.6349063799944 * s*s*s)){
            sub_reg = 1;
        }
    else{
        if (s < 5.85){
            sub_reg = 3;
        }
        else{
            sub_reg = 2;
        }
    }
    if (sub_reg == 1){
        //Subregion A
        //Table 6, Eq 3, page 8
        int Ii[] = {0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,2,2,2,3,3,3,3,3,4,5,5,6,7};
        int Ji[] = {1,3,6,16,20,22,0,1,2,3,5,6,10,16,20,22,3,16,20,0,2,3,6,16,16,3,16,3,1};
        double ni[] = {-1.82575361923032e-02,-0.125229548799536,0.592290437320145,6.04769706185122,238.624965444474,
        -298.639090222922,0.051225081304075,-0.437266515606486,0.413336902999504,-5.16468254574773,-5.57014838445711,
        12.8555037824478,11.414410895329,-119.504225652714,-2847.7798596156,4317.57846408006,1.1289404080265,1974.09186206319,
        1516.12444706087,1.41324451421235e-02,0.585501282219601,-2.97258075863012,5.94567314847319,-6236.56565798905,
        9659.86235133332,6.81500934948134,-6332.07286824489,-5.5891922446576,4.00645798472063e-02};
        double eta = h / 4200;
        double Sigma = s / 12;
        double Pi = 0;
        for (int i=0;i<29;i++){
            Pi += ni[i] * pow((eta - 0.5) ,Ii[i]) * pow((Sigma - 1.2) , Ji[i]);
            }
        result = Pi*Pi*Pi*Pi * 4;
    }
    else{
        if (sub_reg == 2){
            //Subregion B
            //Table 7, Eq 4, page 9
            int Ii[] = {0,0,0,0,0,1,1,1,1,1,1,2,2,2,3,3,3,3,4,4,5,5,6,6,6,7,7,8,8,8,8,12,14};
            int Ji[] = {0,1,2,4,8,0,1,2,3,5,12,1,6,18,0,1,7,12,1,16,1,12,1,8,18,1,16,1,3,14,18,10,16};
            double ni[] = {8.01496989929495e-02,-0.543862807146111,0.337455597421283,8.9055545115745,
            313.840736431485,0.797367065977789,-1.2161697355624,8.72803386937477,-16.9769781757602,
            -186.552827328416,95115.9274344237,-18.9168510120494,-4334.0703719484,543212633.012715,
            0.144793408386013,128.024559637516,-67230.9534071268,33697238.0095287,-586.63419676272,
            -22140322476.9889,1716.06668708389,-570817595.806302,-3121.09693178482,-2078413.8463301,
            3056059461577.86,3221.57004314333,326810259797.295,-1441.04158934487,410.694867802691,
            109077066873.024,-24796465425889.3,1888019068.65134,-123651009018773};
            double eta = h / 4100;
            double Sigma = s / 7.9;
            double Pi = 0;
            for (int i=0; i<33; i++){
                Pi += ni[i] * pow((eta - 0.6),Ii[i]) * pow((Sigma - 1.01),Ji[i]);
                }
            result = Pi*Pi*Pi*Pi * 100;
        }
        else{
            //Subregion C
            //Table 8, Eq 5, page 10
            int Ii[] = {0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,5,5,5,5,6,6,10,12,16};
            int Ji[] = {0,1,2,3,4,8,0,2,5,8,14,2,3,7,10,18,0,5,8,16,18,18,1,4,6,14,8,18,7,7,10};
            double ni[] = {0.112225607199012,-3.39005953606712,-32.0503911730094,-197.5973051049,-407.693861553446,
            13294.3775222331,1.70846839774007,37.3694198142245,3581.44365815434,423014.446424664,-751071025.760063,
            52.3446127607898,-228.351290812417,-960652.417056937,-80705929.2526074,1626980172256.69,0.772465073604171,
            46392.9973837746,-13731788.5134128,1704703926305.12,-25110462818730.8,31774883083552,53.8685623675312,
            -55308.9094625169,-1028615.22421405,2042494187562.34,273918446.626977,-2.63963146312685e15,-1078908541.08088,
            -29649262098.0124,-1.11754907323424e15};
            double eta = h / 3500;
            double Sigma = s / 5.9;
            double Pi = 0;
            for (int i=0; i<31;i++){
                Pi += ni[i] * pow((eta - 0.7),Ii[i]) * pow((Sigma - 1.1) , Ji[i]);
            }
            result = Pi*Pi*Pi*Pi* 100;
        }
    }
    return result;
}

double T2_prho(double p, double rho) {
    double Low_Bound, High_Bound, rhos, last_rhos, Ts;
    int step_counter = 0;

    if (p < 16.5292) {
        Low_Bound = T4_p(p);
    } else {
        Low_Bound = B23T_p(p);
    }

    High_Bound = 1073.15;
    rhos = -1000;

    while (fabs(rho - rhos) > 0.000001) {
        step_counter++;
        last_rhos = rhos;

        Ts = (Low_Bound + High_Bound) / 2;
        rhos = 1 / v2_pT(p, Ts);

        if (last_rhos == rhos) {
            printf("T2_prho stopped iterating after %d steps because values did not converge\n", step_counter);
            break;
        }

        if (rhos < rho) {
            High_Bound = Ts;
        } else {
            Low_Bound = Ts;
        }
    }

    return Ts;
}

double p3_rhoT(double rho, double T) {
    double Ii[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11};
    double Ji[] = {0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26};
    double ni[] = {1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502e-03, -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946, -2.018991502357, -8.2147637173963e-03, -0.47596035734923, 0.0439840744735, -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084e-04, 3.2308904703711e-03, 8.0964802996215e-05, -1.6557679795037e-04, -4.4923899061815e-05};

    double R = SPECIFIC_GAS_CONSTANT;
    double tc = CRITICAL_TEMPERATURE;
    double rhoc = 322.0;
    double delta = rho / rhoc;
    double tau = tc / T;
    double fidelta = 0;
    for (int i=0; i<40;i++){
        fidelta += ni[i] * Ii[i] * pow(delta, (Ii[i] - 1)) * pow(tau , Ji[i]);
    }
    fidelta = fidelta + (ni[0] / delta);
    return (rho * R * T * delta * fidelta) / 1000.0;
}

double u3_rhoT(double rho, double T) {
    double Ii[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11};
    double Ji[] = {0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26};
    double ni[] = {1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502e-03, -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946, -2.018991502357, -8.2147637173963e-03, -0.47596035734923, 0.0439840744735, -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084e-04, 3.2308904703711e-03, 8.0964802996215e-05, -1.6557679795037e-04, -4.4923899061815e-05};

    double R = SPECIFIC_GAS_CONSTANT;
    double tc = CRITICAL_TEMPERATURE;
    double rhoc = 322.0;
    double delta = rho / rhoc;
    double tau = tc / T;
    double fitau = 0;

    for (int i=0;i<40;i++){
            fitau = fitau + ni[i] * pow(delta , Ii[i]) * Ji[i] * pow(tau , (Ji[i] - 1));
        }
    return R * T * (tau * fitau);
}

double h3_rhoT(double rho, double T) {
    double Ii[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11};
    double Ji[] = {0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26};
    double ni[] = {1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502e-03, -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946, -2.018991502357, -8.2147637173963e-03, -0.47596035734923, 0.0439840744735, -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084e-04, 3.2308904703711e-03, 8.0964802996215e-05, -1.6557679795037e-04, -4.4923899061815e-05};

    double R = SPECIFIC_GAS_CONSTANT;
    double tc = CRITICAL_TEMPERATURE;
    double rhoc = 322.0;
    double delta = rho / rhoc;
    double tau = tc / T;
    double fidelta = 0;
    double fitau = 0;
    for (int i = 1; i < 40; i++) {
        fidelta = fidelta + ni[i] * Ii[i] * pow(delta, Ii[i] - 1) * pow(tau, Ji[i]);
        fitau = fitau + ni[i] * pow(delta, Ii[i]) * Ji[i] * pow(tau, Ji[i] - 1);
    }
    fidelta = fidelta + ni[0] / delta;
    return R * T * (tau * fitau + delta * fidelta);
}

double s3_rhoT(double rho, double T) {
    double Ii[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11};
    double Ji[] = {0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26};
    double ni[] = {1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502e-03, -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946, -2.018991502357, -8.2147637173963e-03, -0.47596035734923, 0.0439840744735, -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084e-04, 3.2308904703711e-03, 8.0964802996215e-05, -1.6557679795037e-04, -4.4923899061815e-05};
    double R = SPECIFIC_GAS_CONSTANT;
    double tc = CRITICAL_TEMPERATURE;
    double rhoc = 322.0;  // kg/m3
    double delta = rho / rhoc;
    double tau = tc / T;
    double fi = 0;
    double fitau = 0;
    for (int i = 1; i < 40; i++) {
        fi = fi + ni[i] * pow(delta, Ii[i]) * pow(tau, Ji[i]);
        fitau = fitau + ni[i] * pow(delta, Ii[i]) * Ji[i] * pow(tau, Ji[i] - 1);
    }
    fi = fi + ni[0] * log(delta);
    return R * (tau * fitau - fi);
}

double Cp3_rhoT(double rho, double T) {
    double Ii[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11
    };
    double Ji[] = {
        0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26
    };
    double ni[] = {
        1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502e-03, -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946, -2.018991502357, -8.2147637173963e-03, -0.47596035734923, 0.0439840744735, -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084e-04, 3.2308904703711e-03, 8.0964802996215e-05, -1.6557679795037e-04, -4.4923899061815e-05
    };
    double R = SPECIFIC_GAS_CONSTANT;
    double tc = CRITICAL_TEMPERATURE;
    double rhoc = 322.0;
    double delta = rho / rhoc;
    double tau = tc / T;
    double fitautau = 0;
    double fidelta = 0;
    double fideltatau = 0;
    double fideltadelta = 0;
    for (int i = 1; i < 40; i++) {
        fitautau = fitautau + ni[i] * pow(delta, Ii[i]) * Ji[i] * (Ji[i] - 1) * pow(tau, Ji[i] - 2);
        fidelta = fidelta + ni[i] * Ii[i] * pow(delta, Ii[i] - 1) * pow(tau, Ji[i]);
        fideltatau = fideltatau + ni[i] * Ii[i] * pow(delta, Ii[i] - 1) * Ji[i] * pow(tau, Ji[i] - 1);
        fideltadelta = fideltadelta + ni[i] * Ii[i] * (Ii[i] - 1) * pow(delta, Ii[i] - 2) * pow(tau, Ji[i]);
    }
    fidelta = fidelta + ni[0] / delta;
    fideltadelta = fideltadelta - ni[0] / (delta * delta);
    return R * (-(tau * tau) * fitautau + pow(delta * fidelta - delta * tau * fideltatau, 2) / (2 * delta * fidelta + delta * delta * fideltadelta));

}

double Cv3_rhoT(double rho, double T) {
    int Ii[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11};
    int Ji[] = {0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26};
    double ni[] = {1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502e-03, -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946, -2.018991502357, -8.2147637173963e-03, -0.47596035734923, 0.0439840744735, -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084e-04, 3.2308904703711e-03, 8.0964802996215e-05, -1.6557679795037e-04, -4.4923899061815e-05};

    double R = SPECIFIC_GAS_CONSTANT;
    double tc = CRITICAL_TEMPERATURE;
    double rhoc = 322.0;
    double delta = rho / rhoc;
    double tau = tc / T;
    double fitautau = 0;

    for (int i = 1; i < 40; i++) {
        fitautau += ni[i] * pow(delta, Ii[i]) * Ji[i] * (Ji[i] - 1) * pow(tau, Ji[i] - 2);
    }
    return R * -(tau * tau * fitautau);
}

double w3_rhoT(double rho, double T) {
    int Ii[] = {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        6,
        6,
        6,
        7,
        8,
        9,
        9,
        10,
        10,
        11
    };
    int Ji[] = {
        0,
        0,
        1,
        2,
        7,
        10,
        12,
        23,
        2,
        6,
        15,
        17,
        0,
        2,
        6,
        7,
        22,
        26,
        0,
        2,
        4,
        16,
        26,
        0,
        2,
        4,
        26,
        1,
        3,
        26,
        0,
        2,
        26,
        2,
        26,
        2,
        26,
        0,
        1,
        26
    };
    double ni[] = {
            1.0658070028513,
            -15.732845290239,
            20.944396974307,
            -7.6867707878716,
            2.6185947787954,
            -2.808078114862,
            1.2053369696517,
            -8.4566812812502e-03,
            -1.2654315477714,
            -1.1524407806681,
            0.88521043984318,
            -0.64207765181607,
            0.38493460186671,
            -0.85214708824206,
            4.8972281541877,
            -3.0502617256965,
            0.039420536879154,
            0.12558408424308,
            -0.2799932969871,
            1.389979956946,
            -2.018991502357,
            -8.2147637173963e-03,
            -0.47596035734923,
            0.0439840744735,
            -0.44476435428739,
            0.90572070719733,
            0.70522450087967,
            0.10770512626332,
            -0.32913623258954,
            -0.50871062041158,
            -0.022175400873096,
            0.094260751665092,
            0.16436278447961,
            -0.013503372241348,
            -0.014834345352472,
            5.7922953628084e-04,
            3.2308904703711e-03,
            8.0964802996215e-05,
            -1.6557679795037e-04,
            -4.4923899061815e-05
        };
    double R = SPECIFIC_GAS_CONSTANT;
    double tc = CRITICAL_TEMPERATURE;
    double rhoc = 322.0; // kg/m3
    double delta = rho / rhoc;
    double tau = tc / T;
    double fitautau = 0;
    double fidelta = 0;
    double fideltatau = 0;
    double fideltadelta = 0;
    for (int i = 1; i < 40; i++) {
        fitautau += ni[i] * pow(delta, Ii[i]) * Ji[i] * (Ji[i] - 1) * pow(tau, Ji[i] - 2);
        fidelta += ni[i] * Ii[i] * pow(delta, Ii[i] - 1) * pow(tau, Ji[i]);
        fideltatau += ni[i] * Ii[i] * pow(delta, Ii[i] - 1) * Ji[i] * pow(tau, Ji[i] - 1);
        fideltadelta += ni[i] * Ii[i] * (Ii[i] - 1) * pow(delta, Ii[i] - 2) * pow(tau, Ji[i]);
    }
    fidelta = fidelta + ni[0] / delta;
    fideltadelta = fideltadelta - ni[0] / (delta*delta);
    return sqrt(1000 * R * T * ( 2 * delta * fidelta + delta*delta * fideltadelta -
                                (delta * fidelta - delta * tau * fideltatau) *(delta * fidelta - delta * tau * fideltatau)
                                / (tau*tau * fitautau)));
}

double T3_ph(double p, double h) {
    double h3ab = 2014.64004206875 + 3.74696550136983 * p - 2.19921901054187e-02 * p * p + 8.7513168600995e-05 * p * p * p;

    if (h < h3ab) {
        // Subregion 3a
        int Ii[] = {-12, -12, -12, -12, -12, -12, -12, -12, -10, -10, -10, -8, -8, -8, -8, -5, -3, -2, -2, -2, -1, -1, 0, 0, 1, 3, 3, 4, 4, 10, 12};
        int Ji[] = {0, 1, 2, 6, 14, 16, 20, 22, 1, 5, 12, 0, 2, 4, 10, 2, 0, 1, 3, 4, 0, 2, 0, 1, 1, 0, 1, 0, 3, 4, 5};
        double ni[] = {-1.33645667811215e-07, 4.55912656802978e-06, -1.46294640700979e-05, 6.3934131297008e-03, 372.783927268847, -7186.54377460447, 573494.7521034, -2675693.29111439, -3.34066283302614e-05, -2.45479214069597e-02, 47.8087847764996, 7.64664131818904e-06, 1.28350627676972e-03, 1.71219081377331e-02, -8.51007304583213, -1.36513461629781e-02, -3.84460997596657e-06, 3.37423807911655e-03, -0.551624873066791, 0.72920227710747, -9.92522757376041e-03, -0.119308831407288, 0.793929190615421, 0.454270731799386, 0.20999859125991, -6.42109823904738e-03, -0.023515586860454, 2.52233108341612e-03, -7.64885133368119e-03, 1.36176427574291e-02, -1.33027883575669e-02};

        double ps = p / 100;
        double hs = h / 2300;
        double Ts = 0;

        // Calculate Ts using equations
        for (int i = 0; i < 31; i++) {
            Ts = Ts + ni[i] * pow((ps + 0.24),Ii[i]) * pow((hs - 0.615),Ji[i]);
        }
        return Ts*760; // Convert back to Kelvin
    }
    else {
        // Subregion 3b
        int Ii[] = {-12, -12, -10, -10, -10, -10, -10, -8, -8, -8, -8, -8, -6, -6, -6, -4, -4, -3, -2, -2, -1, -1, -1, -1, -1, -1, 0, 0, 1, 3, 5, 6, 8};
        int Ji[] = {0, 1, 0, 1, 5, 10, 12, 0, 1, 2, 4, 10, 0, 1, 2, 0, 1, 5, 0, 4, 2, 4, 6, 10, 14, 16, 0, 2, 1, 1, 1, 1, 1, 1};
        double ni[] = {3.2325457364492e-05, -1.27575556587181e-04, -4.75851877356068e-04, 1.56183014181602e-03, 0.105724860113781, -85.8514221132534, 724.140095480911, 2.96475810273257e-03, -5.92721983365988e-03, -1.26305422818666e-02, -0.115716196364853, 84.9000969739595, -1.08602260086615e-02, 1.54304475328851e-02, 7.50455441524466e-02, 2.52520973612982e-02, -6.02507901232996e-02, -3.07622221350501, -5.74011959864879e-02, 5.03471360939849, -0.925081888584834, 3.91733882917546, -77.314600713019, 9493.08762098587, -1410437.19679409, 8491662.30819026, 0.861095729446704, 0.32334644281172, 0.873281936020439, -0.436653048526683, 0.286596714529479, -0.131778331276228, 6.76682064330275e-03};

        double hs = h / 2800;
        double ps = p / 100;
        double Ts = 0;

        // Calculate Ts using equations
        for (int i = 0; i < 33; i++) {
            Ts += ni[i] * pow(ps + 0.298, Ii[i]) * pow(hs - 0.72, Ji[i]);
        }
        return Ts * 860;  // Convert back to Kelvin
        }
}

double v3_ph(double p, double h) {
    double h3ab = 2014.64004206875 + 3.74696550136983 * p - 2.19921901054187e-02 * pow(p, 2) + 8.7513168600995e-05 * pow(p, 3);

    if (h < h3ab) {
        // Subregion 3a
        int Ii[] = {-12, -12, -12, -12, -10, -10, -10, -8, -8, -6, -6, -6, -4, -4, -3, -2, -2, -1, -1, -1, -1, 0, 0, 1, 1, 1, 2, 2, 3, 4, 5, 8};
        int Ji[] = {6, 8, 12, 18, 4, 7, 10, 5, 12, 3, 4, 22, 2, 3, 7, 3, 16, 0, 1, 2, 3, 0, 1, 0, 1, 2, 0, 2, 0, 2, 2, 2};
        double ni[] = {5.29944062966028e-03, -0.170099690234461, 11.1323814312927, -2178.98123145125, -5.06061827980875e-04, 0.556495239685324, -9.43672726094016, -0.297856807561527, 93.9353943717186, 1.92944939465981e-02, 0.421740664704763, -3689141.2628233, -7.37566847600639e-03, -0.354753242424366, -1.99768169338727, 1.15456297059049, 5683.6687581596, 8.08169540124668e-03, 0.172416341519307, 1.04270175292927, -0.297691372792847, 0.560394465163593, 0.275234661176914, -0.148347894866012, -6.51142513478515e-02, -2.92468715386302, 6.64876096952665e-02, 3.52335014263844, -1.46340792313332e-02, -2.24503486668184, 1.10533464706142, -4.08757344495612e-02};

        double ps = p / 100;
        double hs = h / 2100;
        double vs = 0;

        // Calculate vs using equations
        for (int i = 0; i < 32; i++) {
            vs += ni[i] * pow(ps + 0.128, Ii[i]) * pow(hs - 0.727, Ji[i]);
        }

        return vs * 0.0028;
    }
    else {
        // Subregion 3b
        int Ii[] = {-12, -12, -8, -8, -8, -8, -8, -8, -6, -6, -6, -6, -6, -6, -4, -4, -4, -3, -3, -2, -2, -1, -1, -1, -1, 0, 1, 1, 2, 2};
        int Ji[] = {0, 1, 0, 1, 3, 6, 7, 8, 0, 1, 2, 5, 6, 10, 3, 6, 10, 0, 2, 1, 2, 0, 1, 4, 5, 0, 0, 1, 2, 6};
        double ni[] = {-2.25196934336318e-09, 1.40674363313486e-08, 2.3378408528056e-06, -3.31833715229001e-05, 1.07956778514318e-03, -0.271382067378863, 1.07202262490333, -0.853821329075382, -2.15214194340526e-05, 7.6965608822273e-04, -4.31136580433864e-03, 0.453342167309331, -0.507749535873652, -100.475154528389, -0.219201924648793, -3.21087965668917, 607.567815637771, 5.57686450685932e-04, 0.18749904002955, 9.05368030448107e-03, 0.285417173048685, 3.29924030996098e-02, 0.239897419685483, 4.82754995951394, -11.8035753702231, 0.169490044091791, -1.79967222507787e-02, 3.71810116332674e-02, -5.36288335065096e-02, 1.6069710109252};

        double ps = p / 100;
        double hs = h / 2800;
        double vs = 0;

        // Calculate vs using equations
        for (int i = 0; i < 30; i++) {
            vs += ni[i] * pow(ps + 0.0661, Ii[i]) * pow(hs - 0.72, Ji[i]);
        }

        return vs * 0.0088;
    }
}

double T3_ps(double p, double s) {


    if (s <= 4.41202148223476) {
        // Subregion 3a
        // Eq 6, Table 10, Page 11
        int Ii[33] = {-12, -12, -10, -10, -10, -10, -8, -8, -8, -8, -6, -6, -6, -5, -5, -5, -4, -4, -4, -2, -2, -1, -1, 0, 0, 0, 1, 2, 2, 3, 8, 8, 10};
        int Ji[33] = {28, 32, 4, 10, 12, 14, 5, 7, 8, 28, 2, 6, 32, 0, 14, 32, 6, 10, 36, 1, 4, 1, 6, 0, 1, 4, 0, 0, 3, 2, 0, 1, 2};
        double ni[33] = {1500420082.63875, -159397258480.424, 5.02181140217975e-04, -67.2057767855466, 1450.58545404456, -8238.8953488889, -0.154852214233853, 11.2305046746695, -29.7000213482822, 43856513263.5495, 1.37837838635464e-03, -2.97478527157462, 9717779473494.13, -5.71527767052398e-05, 28830.794977842, -74442828926270.3, 12.8017324848921, -368.275545889071, 6.64768904779177e15, 0.044935925195888, -4.22897836099655, -0.240614376434179, -4.74341365254924, 0.72409399912611, 0.923874349695897, 3.99043655281015, 3.84066651868009e-02, -3.59344365571848e-03, -0.735196448821653, 0.188367048396131, 1.41064266818704e-04, -2.57418501496337e-03, 1.23220024851555e-03};
        double Sigma, Pi, teta;
        Sigma = s / 4.4;
        Pi = p / 100;
        teta = 0;

        for (int i = 0; i < 33; i++) {
            teta += ni[i] * pow((Pi + 0.24), Ii[i]) * pow((Sigma - 0.703), Ji[i]);
        }

        return teta * 760;
    }
    else {
        // Subregion 3b
        // Eq 7, Table 11, Page 11
        int Ii[28] = {-12, -12, -12, -12, -8, -8, -8, -6, -6, -6, -5, -5, -5, -5, -5, -4, -3, -3, -2, 0, 2, 3, 4, 5, 6, 8, 12, 14};
        int Ji[28] = {1, 3, 4, 7, 0, 1, 3, 0, 2, 4, 0, 1, 2, 4, 6, 12, 1, 6, 2, 0, 1, 1, 0, 24, 0, 3, 1, 2};
        double ni[28] = {0.52711170160166, -40.1317830052742, 153.020073134484, -2247.99398218827, -0.193993484669048, -1.40467557893768, 42.6799878114024, 0.752810643416743, 22.6657238616417, -622.873556909932, -0.660823667935396, 0.841267087271658, -25.3717501764397, 485.708963532948, 880.531517490555, 2650155.92794626, -0.359287150025783, -656.991567673753, 2.41768149185367, 0.856873461222588, 0.655143675313458, -0.213535213206406, 5.62974957606348e-03, -316955725450471, -6.99997000152457e-04, 1.19845803210767e-02, 1.93848122022095e-05, -2.15095749182309e-05};
        double Sigma = s / 5.3;
        double Pi = p / 100;
        double teta = 0;

        for (int i = 0; i < 28; i++) {
            teta += ni[i] * pow((Pi + 0.76), Ii[i]) * pow((Sigma - 0.818), Ji[i]);
        }

        return teta * 860;
    }
}

double v3_ps(double p, double s) {
    /* Revised Supplementary Release on Backward Equations for the functions T(p, h), v(p, h) and T(p, s), v(p, s) for Region 3 of the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam 2004
     * 3.4 Backward Equations T(p, s) and v(p, s) for Subregions 3a and 3b
     * Boundary equation, Eq 6 Page 11
     */
    if (s <= 4.41202148223476) {
        // Subregion 3a
        // Eq 8, Table 13, Page 14
        double Ii[28] = {-12, -12, -12, -10, -10, -10, -10, -8, -8, -8, -8, -6, -5, -4, -3, -3, -2, -2, -1, -1, 0, 0, 0, 1, 2, 4, 5, 6};
        double Ji[28] = {10, 12, 14, 4, 8, 10, 20, 5, 6, 14, 16, 28, 1, 5, 2, 4, 3, 8, 1, 2, 0, 1, 3, 0, 0, 2, 2, 0};
        double ni[28] = {79.5544074093975, -2382.6124298459, 17681.3100617787, -1.10524727080379e-03, -15.3213833655326, 297.544599376982, -35031520.6871242, 0.277513761062119, -0.523964271036888, -148011.182995403, 1600148.99374266, 1708023226634.27, 2.46866996006494e-04, 1.6532608479798, -0.118008384666987, 2.537986423559, 0.965127704669424, -28.2172420532826, 0.203224612353823, 1.10648186063513, 0.52612794845128, 0.277000018736321, 1.08153340501132, -7.44127885357893e-02, 1.64094443541384e-02, -6.80468275301065e-02, 0.025798857610164, -1.45749861944416e-04};
        double Pi = p / 100;
        double Sigma = s / 4.4;
        double omega = 0;

        for (int i = 0; i < 28; i++) {
            omega += ni[i] * pow((Pi + 0.187), Ii[i]) * pow((Sigma - 0.755), Ji[i]);
        }

        return omega * 0.0028;
    }
    else {
    // Subregion 3b
    // Eq 9, Table 14, Page 14
    double Ii[31] = {-12, -12, -12, -12, -12, -12, -10, -10, -10, -10, -8, -5, -5, -5, -4, -4, -4, -4, -3, -2, -2, -2, -2, -2, -2, 0, 0, 0, 1, 1, 2};
    double Ji[31] = {0, 1, 2, 3, 5, 6, 0, 1, 2, 4, 0, 1, 2, 3, 0, 1, 2, 3, 1, 0, 1, 2, 3, 4, 12, 0, 1, 2, 0, 2, 2};
    double ni[31] = {5.91599780322238e-05, -1.85465997137856e-03, 1.04190510480013e-02, 5.9864730203859e-03, -0.771391189901699, 1.72549765557036, -4.67076079846526e-04, 1.34533823384439e-02, -8.08094336805495e-02, 0.508139374365767, 1.28584643361683e-03, -1.63899353915435, 5.86938199318063, -2.92466667918613, -6.14076301499537e-03, 5.76199014049172, -12.1613320606788, 1.67637540957944, -7.44135838773463, 3.78168091437659e-02, 4.01432203027688, 16.0279837479185, 3.17848779347728, -3.58362310304853, -1159952.60446827, 0.199256573577909, -0.122270624794624, -19.1449143716586, -1.50448002905284e-02, 14.6407900162154, -3.2747778718823};
    double Pi = p / 100;
    double Sigma = s / 5.3;
    double omega = 0;

    for (int i = 0; i < 31; i++) {
        omega += ni[i] * pow((Pi + 0.298), Ii[i]) * pow((Sigma - 0.816), Ji[i]);
    }

    return omega * 0.0088;
    }
}

double p3_hs(double h, double s) {
    if (s < 4.41202148223476) {
        // Subregion 3a
        // Eq 1, Table 3, Page 8
        double Ii[] = {0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 6, 7, 8, 10, 10, 14, 18, 20, 22, 22, 24, 28, 28, 32, 32};
        double Ji[] = {0, 1, 5, 0, 3, 4, 8, 14, 6, 16, 0, 2, 3, 0, 1, 4, 5, 28, 28, 24, 1, 32, 36, 22, 28, 36, 16, 28, 36, 16, 36, 10, 28};
        double ni[] = {7.70889828326934, -26.0835009128688, 267.416218930389, 17.2221089496844, -293.54233214597, 614.135601882478, -61056.2757725674, -65127225.1118219, 73591.9313521937, -11664650591.4191, 35.5267086434461, -596.144543825955, -475.842430145708, 69.6781965359503, 335.674250377312, 25052.6809130882, 146997.380630766, 5.38069315091534e19, 1.43619827291346e21, 3.64985866165994e19, -2547.41561156775, 2.40120197096563e27, -3.93847464679496e29, 1.47073407024852e24, -4.26391250432059e31, 1.94509340621077e38, 6.66212132114896e23, 7.06777016552858e33, 1.75563621975576e41, 1.08408607429124e28, 7.30872705175151e43, 1.5914584739887e24, 3.77121605943324e40};
        double Sigma = s / 4.4;
        double eta = h / 2300;
        double Pi = 0;
        for (int i = 0; i < 33; i++) {
            Pi += ni[i] * pow((eta - 1.01), Ii[i]) * pow((Sigma - 0.75), Ji[i]);
        }
        return Pi * 99;
    }

    else {
    // Subregion 3b
    // Eq 2, Table 4, Page 8
    double Ii[] = {-12, -12, -12, -12, -12, -10, -10, -10, -10, -8, -8, -6, -6, -6, -6, -5, -4, -4, -4, -3, -3, -3, -3, -2, -2, -1, 0, 2, 2, 5, 6, 8, 10, 14, 14};
    double Ji[] = {2, 10, 12, 14, 20, 2, 10, 14, 18, 2, 8, 2, 6, 7, 8, 10, 4, 5, 8, 1, 3, 5, 6, 0, 1, 0, 3, 0, 1, 0, 1, 1, 1, 3, 7};
    double ni[] = {1.25244360717979e-13, -1.26599322553713e-02, 5.06878030140626, 31.7847171154202, -391041.161399932, -9.75733406392044e-11, -18.6312419488279, 510.973543414101, 373847.005822362, 2.99804024666572e-08, 20.0544393820342, -4.98030487662829e-06, -10.230180636003, 55.2819126990325, -206.211367510878, -7940.12232324823, 7.82248472028153, -58.6544326902468, 3550.73647696481, -1.15303107290162e-04, -1.75092403171802, 257.98168774816, -727.048374179467, 1.21644822609198e-04, 3.93137871762692e-02, 7.04181005909296e-03, -82.910820069811, -0.26517881813125, 13.7531682453991, -52.2394090753046, 2405.56298941048, -22736.1631268929, 89074.6343932567, -23923456.5822486, 5687958081.29714};
    double Sigma = s / 5.3;
    double eta = h / 2800;
    double Pi = 0;
    for (int i = 0; i < 35; i++) {
        Pi += ni[i] * pow((eta - 0.681), Ii[i]) * pow((Sigma - 0.792), Ji[i]);
    }
    return 16.6 / Pi;
    }
}

double h3_pT(double p, double T) {
    double Ts, High_Bound, Low_Bound, hs, last_Ts;
    int step_counter = 0;

    if (p < 22.06395) {
        Ts = T4_p(p);  // Saturation temperature
        if (T <= Ts) {
            High_Bound = h4L_p(p);  // Max h for liquid h
            Low_Bound = h1_pT(p, 623.15);
        } else {
            Low_Bound = h4V_p(p);  // Min h for vapor h
            High_Bound = h2_pT(p, B23T_p(p));
        }
    } else {
        Low_Bound = h1_pT(p, 623.15);
        High_Bound = h2_pT(p, B23T_p(p));
    }

    Ts = T + 1;
    while (fabs(T - Ts) > 0.00001) {
        step_counter += 1;
        last_Ts = Ts;

        hs = (Low_Bound + High_Bound) / 2;
        Ts = T3_ph(p, hs);

        if (last_Ts == Ts) {
            printf("h3_pT stopped iterating after %d steps because values did not converge", step_counter);
            break;
        }

        if (Ts > T) {
            High_Bound = hs;
        } else {
            Low_Bound = hs;
        }
    }

    return hs;
}

double T3_prho(double p, double rho) {
    // Observe that of low temperatures this equation has 2 solutions.
    // Solve with half interval method
    double Low_Bound = 623.15;
    double High_Bound = 1073.15;
    double ps = -1000;
    double Ts;
    int step_counter = 0;

    while (fabs(p - ps) > 0.00000001) {
        step_counter++;
        double last_ps = ps;

        Ts = (Low_Bound + High_Bound) / 2;
        ps = p3_rhoT(rho, Ts);  // Replace p3_rhoT with the appropriate function

        if (last_ps == ps) {
            printf("T3_prho stopped iterating after %d steps because values did not converge", step_counter);
            break;
        }

        if (ps > p) {
            High_Bound = Ts;
        } else {
            Low_Bound = Ts;
        }
    }

    return Ts;
}

double p4_T(double T) {
    double teta = T - 0.23855557567849 / (T - 650.17534844798);
    double a = teta * teta + 1167.0521452767 * teta - 724213.16703206;
    double B = -17.073846940092 * teta * teta + 12020.82470247 * teta - 3232555.0322333;
    double C = 14.91510861353 * teta * teta - 4823.2657361591 * teta + 405113.40542057;
    return pow(2 * C / (-B + sqrt(B * B - 4 * a * C)), 4);
}

double T4_p(double p) {
    double beta = pow(p, 0.25);
    double E = beta * beta - 17.073846940092 * beta + 14.91510861353;
    double f = 1167.0521452767 * beta * beta + 12020.82470247 * beta - 4823.2657361591;
    double G = -724213.16703206 * beta * beta - 3232555.0322333 * beta + 405113.40542057;
    double D = 2 * G / (-f - sqrt(f * f - 4 * E * G));
    return (650.17534844798 + D - sqrt(pow(650.17534844798 + D, 2) - 4 * (-0.23855557567849 + 650.17534844798 * D))) / 2;
}

double h4_s(double s) {
    double h4_s;

    if (s > -0.0001545495919 && s <= 3.77828134) {
        // hL1_s
        // Eq 3, Table 9, Page 16
        double Ii[27] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 7, 8, 12, 12, 14, 14, 16, 20, 20, 22, 24, 28, 32, 32};
        double Ji[27] = {14, 36, 3, 16, 0, 5, 4, 36, 4, 16, 24, 18, 24, 1, 4, 2, 4, 1, 22, 10, 12, 28, 8, 3, 0, 6, 8};
        double ni[27] = {0.332171191705237, 6.11217706323496e-04, -8.82092478906822, -0.45562819254325, -2.63483840850452e-05, -22.3949661148062, -4.28398660164013, -0.616679338856916, -14.682303110404, 284.523138727299, -113.398503195444, 1156.71380760859, 395.551267359325, -1.54891257229285, 19.4486637751291, -3.57915139457043, -3.35369414148819, -0.66442679633246, 32332.1885383934, 3317.66744667084, -22350.1257931087, 5739538.75852936, 173.226193407919, -3.63968822121321e-02, 8.34596332878346e-07, 5.03611916682674, 65.5444787064505};

        double Sigma = s / 3.8;
        double eta = 0;
        for (int i = 0; i < 27; i++) {
            eta += ni[i] * pow((Sigma - 1.09), Ii[i]) * pow((Sigma + 0.0000366), Ji[i]);
        }
        return eta * 1700;
    }
    else if ((s > 3.77828134) && (s <= 4.41202148223476)) {
    // hL3_s
    // Eq 4, Table 10, Page 16
    int Ii[] = {0, 0, 0, 0, 2, 3, 4, 4, 5, 5, 6, 7, 7, 7, 10, 10, 10, 32, 32};
    int Ji[] = {1, 4, 10, 16, 1, 36, 3, 16, 20, 36, 4, 2, 28, 32, 14, 32, 36, 0, 6};
    double ni[] = {
        0.822673364673336,
        0.181977213534479,
        -0.011200026031362,
        -7.46778287048033e-04,
        -0.179046263257381,
        4.24220110836657e-02,
        -0.341355823438768,
        -2.09881740853565,
        -8.22477343323596,
        -4.99684082076008,
        0.191413958471069,
        5.81062241093136e-02,
        -1655.05498701029,
        1588.70443421201,
        -85.0623535172818,
        -31771.4386511207,
        -94589.0406632871,
        -1.3927384708869e-06,
        0.63105253224098
    };
    double Sigma = s / 3.8;
    double eta = 0;
    for (int i = 0; i < 19; i++) {
        eta += ni[i] * pow(Sigma - 1.09, Ii[i]) * pow(Sigma + 0.0000366, Ji[i]);
    }
    return eta * 1700;
    }
    else if ((s > 4.41202148223476) && (s <= 5.85)) {
    // Section 4.4 Equations () 2ab " h s and ( ) 2c3b "h s for the Saturated Vapor Line
    // Page 19, Eq 5
    // hV2c3b_s(s)
    int Ii[] = {0, 0, 0, 1, 1, 5, 6, 7, 8, 8, 12, 16, 22, 22, 24, 36};
    int Ji[] = {0, 3, 4, 0, 12, 36, 12, 16, 2, 20, 32, 36, 2, 32, 7, 20};
    double ni[] = {
        1.04351280732769,
        -2.27807912708513,
        1.80535256723202,
        0.420440834792042,
        -105721.24483466,
        4.36911607493884e24,
        -328032702839.753,
        -6.7868676080427e15,
        7439.57464645363,
        -3.56896445355761e19,
        1.67590585186801e31,
        -3.55028625419105e37,
        396611982166.538,
        -4.14716268484468e40,
        3.59080103867382e18,
        -1.16994334851995e40
    };
    double Sigma = s / 5.9;
    double eta = 0;
    for (int i = 0; i < 16; i++) {
        eta += ni[i] * pow(Sigma - 1.02, Ii[i]) * pow(Sigma - 0.726, Ji[i]);
    }
    return eta*eta*eta*eta * 2800;
    }

    else if ((s > 5.85) && (s < 9.155759395)) {
    // Section 4.4 Equations () 2ab " h s and ( ) 2c3b "h s for the Saturated Vapor Line
    // Page 20, Eq 6
    int Ii[] = {
        1, 1, 2, 2, 4, 4, 7, 8, 8, 10, 12, 12, 18, 20, 24, 28, 28, 28, 28, 28,
        32, 32, 32, 32, 32, 36, 36, 36, 36, 36
    };
    int Ji[] = {
        8, 24, 4, 32, 1, 2, 7, 5, 12, 1, 0, 7, 10, 12, 32, 8, 12, 20, 22, 24,
        2, 7, 12, 14, 24, 10, 12, 20, 22, 28
    };
    double ni[] = {
        -524.581170928788, -9269472.18142218, -237.385107491666, 21077015581.2776,
        -23.9494562010986, 221.802480294197, -5104725.33393438, 1249813.96109147,
        2000084369.96201, -815.158509791035, -157.612685637523, -11420042233.2791,
        6.62364680776872e15, -2.27622818296144e18, -1.71048081348406e31,
        6.60788766938091e15, 1.66320055886021e22, -2.18003784381501e29,
        -7.87276140295618e29, 1.51062329700346e31, 7957321.70300541,
        1.31957647355347e15, -3.2509706829914e23, -4.18600611419248e25,
        2.97478906557467e34, -9.53588761745473e19, 1.66957699620939e24,
        -1.75407764869978e32, 3.47581490626396e34, -7.10971318427851e38
    };
    double Sigma1 = s / 5.21;
    double Sigma2 = s / 9.2;
    double eta = 0;
    for (int i = 0; i < 30; i++) {
        eta += ni[i] * pow(1 / Sigma1 - 0.513, Ii[i]) * pow(Sigma2 - 0.524, Ji[i]);
    }
    return exp(eta) * 2800;
    }
    else {
        return -99999;
    }
}

double p4_s(double s) {
    double h_sat = h4_s(s);
    double p4;

    if (s > -0.0001545495919 && s <= 3.77828134) {
        p4 = p1_hs(h_sat, s);
    } else if (s > 3.77828134 && s <= 5.210887663) {
        p4 = p3_hs(h_sat, s);
    } else if (s > 5.210887663 && s < 9.155759395) {
        p4 = p2_hs(h_sat, s);
    } else {
        p4 = -99999;
    }

    return p4;
}

double h4L_p(double p) {
    double Ts;
    double h4L, hs;

    if (p > 0.000611657 && p < 22.06395) {
        Ts = T4_p(p);
        if (p < 16.529) {
            h4L = h1_pT(p, Ts);
        } else {
            // Iterar para encontrar la solución inversa de p3sat_h
            double Low_Bound = 1670.858218;
            double High_Bound = 2087.23500164864;
            double ps = -1000;
            int step_counter = 0;

            while (fabs(p - ps) > 0.00001) {
                step_counter++;
                double last_ps = ps;

                hs = (Low_Bound + High_Bound) / 2;
                ps = p3sat_h(hs);

                if (last_ps == ps) {
                    printf("h4L_p se detuvo después de %d iteraciones porque los valores no convergieron\n", step_counter);
                    break;
                }

                if (ps > p) {
                    High_Bound = hs;
                } else {
                    Low_Bound = hs;
                }
            }

            h4L = hs;
        }
    } else {
        h4L = -99999;
    }

    return h4L;
}

double h4V_p(double p) {
    double Ts;
    double h4V_p, hs;

    if (p > 0.000611657 && p < 22.06395) {
        Ts = T4_p(p);
        if (p < 16.529) {
            h4V_p = h2_pT(p, Ts);
        } else {
            // Iterar para encontrar la solución inversa de p3sat_h
            double Low_Bound = 2087.23500164864;
            double High_Bound = 2563.592004 + 5;
            double ps = -1000;
            int step_counter = 0;

            while (fabs(p - ps) > 0.000001) {
                step_counter++;
                double last_ps = ps;

                double hs = (Low_Bound + High_Bound) / 2;
                ps = p3sat_h(hs);

                if (last_ps == ps) {
                    printf("h4V_p se detuvo después de %d iteraciones porque los valores no convergieron\n", step_counter);
                    break;
                }

                if (ps < p) {
                    High_Bound = hs;
                } else {
                    Low_Bound = hs;
                }
            }

            h4V_p = hs;
        }
    } else {
        h4V_p = -99999;
    }

    return h4V_p;
}

double x4_ph(double p, double h) {
    double h4v = h4V_p(p);
    double h4L = h4L_p(p);
    double x4_ph;

    if (h > h4v) {
        x4_ph = 1;
    } else if (h < h4L) {
        x4_ph = 0;
    } else {
        x4_ph = (h - h4L) / (h4v - h4L);
    }

    return x4_ph;
}

double x4_ps(double p, double s) {
    double ssv, ssL, x4_ps;

    if (p < 16.529) {
        ssv = s2_pT(p, T4_p(p));
        ssL = s1_pT(p, T4_p(p));
    } else {
        double v4v = 1 / v3_ph(p, h4V_p(p));
        double v4L = 1 / v3_ph(p, h4L_p(p));
        ssv = s3_rhoT(v4v, T4_p(p));
        ssL = s3_rhoT(v4L, T4_p(p));
    }

    if (s < ssL) {
        x4_ps = 0;
    } else if (s > ssv) {
        x4_ps = 1;
    } else {
        x4_ps = (s - ssL) / (ssv - ssL);
    }

    return x4_ps;
}

double T4_hs(double h, double s) {
    double Low_Bound , High_Bound, hL, PL, Ts, sss, p, xs, s4v, s4L, v4L, v4v;
    double Ii[] = {
        0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 8, 10, 10,
        12, 14, 14, 16, 16, 18, 18, 18, 20, 28
    };
    double Ji[] = {
        0, 3, 12, 0, 1, 2, 5, 0, 5, 8, 0, 2, 3, 4, 0, 1, 1, 2, 4, 16, 6, 8, 22, 1, 20,
        36, 24, 1, 28, 12, 32, 14, 22, 36, 24, 36
    };
    double ni[] = {
        0.179882673606601, -0.267507455199603, 1.162767226126, 0.147545428713616,
        -0.512871635973248, 0.421333567697984, 0.56374952218987, 0.429274443819153,
        -3.3570455214214, 10.8890916499278, -0.248483390456012, 0.30415322190639,
        -0.494819763939905, 1.07551674933261, 7.33888415457688e-02, 1.40170545411085e-02,
        -0.106110975998808, 1.68324361811875e-02, 1.25028363714877, 1013.16840309509,
        -1.51791558000712, 52.4277865990866, 23049.5545563912, 2.49459806365456e-02,
        2107964.67412137, 366836848.613065, -144814105.365163, -1.7927637300359e-03,
        4899556021.00459, 471.262212070518, -82929439019.8652, -1715.45662263191,
        3557776.82973575, 586062760258.436, -12988763.5078195, 31724744937.1057
    };

    if (s > 5.210887825 && s < 9.15546555571324) {
        double Sigma = s / 9.2;
        double eta = h / 2800;
        double teta = 0;

        for (int i = 0; i < 36; i++) {
            teta += ni[i] * pow(eta - 0.119, Ii[i]) * pow(Sigma - 1.07, Ji[i]);
        }

        double T4_hs = teta * 550;
        return T4_hs;
    }

    else if (s > -0.0001545495919 && s <= 3.77828134) {
        Low_Bound = 0.000611;
        High_Bound = 165.291642526045;
        hL = -1000;

        while (fabs(hL - h) > 0.00001 && fabs(High_Bound - Low_Bound) > 0.0001) {
            PL = (Low_Bound + High_Bound) / 2;
            Ts = T4_p(PL);
            hL = h1_pT(PL, Ts);

            if (hL > h) {
                High_Bound = PL;
            } else {
                Low_Bound = PL;
            }
        }
    }
    else if (s > 3.77828134 && s <= 4.41202148223476) {
        PL = p3sat_h(h);
    }
    else if (s > 4.41202148223476 && s <= 5.210887663) {
        PL = p3sat_h(h);
    }

    Low_Bound = 0.000611;
    High_Bound = PL;
    sss = -1000;

    while (fabs(s - sss) > 0.000001 && fabs(High_Bound - Low_Bound) > 0.0000001) {
        p = (Low_Bound + High_Bound) / 2;
        Ts = T4_p(p);
        xs = x4_ph(p, h);

        if (p < 16.529) {
            s4v = s2_pT(p, Ts);
            s4L = s1_pT(p, Ts);
        } else {
            v4v = v3_ph(p, h4V_p(p));
            s4v = s3_rhoT(1 / v4v, Ts);
            v4L = v3_ph(p, h4L_p(p));
            s4L = s3_rhoT(1 / v4L, Ts);
        }

        sss = xs * s4v + (1 - xs) * s4L;

        if (sss < s) {
            High_Bound = p;
        } else {
            Low_Bound = p;
        }
    }

    double T4_hs = T4_p(p);
    return T4_hs;
}

double h5_pT(double p, double T) {
    int Ji0[6] = {0, 1, -3, -2, -1, 2};
    double ni0[6] = {-13.179983674201, 6.8540841634434, -0.024805148933466, 0.36901534980333, -3.1161318213925, -0.32961626538917};
    int Iir[5] = {1, 1, 1, 2, 3};
    int Jir[5] = {0, 1, 3, 9, 3};
    double nir[5] = {-1.2563183589592e-04, 2.1774678714571e-03, -0.004594282089991, -3.9724828359569e-06, 1.2919228289784e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double tau = 1000 / T;
    double Pi = p;
    double gamma0_tau = 0;

    for (int i = 0; i < 6; i++) {
        gamma0_tau += ni0[i] * Ji0[i] * pow(tau, Ji0[i] - 1);
    }

    double gammar_tau = 0;

    for (int i = 0; i < 5; i++) {
        gammar_tau += nir[i] * pow(Pi, Iir[i]) * Jir[i] * pow(tau, Jir[i] - 1);
    }

    return R * T * tau * (gamma0_tau + gammar_tau);
}

double v5_pT(double p, double T) {
    int Iir[5] = {1, 1, 1, 2, 3};
    int Jir[5] = {0, 1, 3, 9, 3};
    double nir[5] = {-1.2563183589592e-04, 2.1774678714571e-03, -0.004594282089991, -3.9724828359569e-06, 1.2919228289784e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double tau = 1000 / T;
    double Pi = p;
    double gamma0_pi = 1 / Pi;
    double gammar_pi = 0;

    for (int i = 0; i < 5; i++) {
        gammar_pi += nir[i] * Iir[i] * pow(Pi, Iir[i] - 1) * pow(tau, Jir[i]);
    }

    return R * T / p * Pi * (gamma0_pi + gammar_pi) / 1000;
}

double u5_pT(double p, double T) {
    int Ji0[6] = {0, 1, -3, -2, -1, 2};
    double ni0[6] = {-13.179983674201, 6.8540841634434, -0.024805148933466, 0.36901534980333, -3.1161318213925, -0.32961626538917};
    int Iir[5] = {1, 1, 1, 2, 3};
    int Jir[5] = {0, 1, 3, 9, 3};
    double nir[5] = {-1.2563183589592e-04, 2.1774678714571e-03, -0.004594282089991, -3.9724828359569e-06, 1.2919228289784e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double tau = 1000 / T;
    double Pi = p;
    double gamma0_pi = 1 / Pi;
    double gamma0_tau = 0;

    for (int i = 0; i < 6; i++) {
        gamma0_tau += ni0[i] * Ji0[i] * pow(tau, Ji0[i] - 1);
    }

    double gammar_pi = 0;
    double gammar_tau = 0;

    for (int i = 0; i < 5; i++) {
        gammar_pi += nir[i] * Iir[i] * pow(Pi, Iir[i] - 1) * pow(tau, Jir[i]);
        gammar_tau += nir[i] * pow(Pi, Iir[i]) * Jir[i] * pow(tau, Jir[i] - 1);
    }

    return R * T * (tau * (gamma0_tau + gammar_tau) - Pi * (gamma0_pi + gammar_pi));
}

double Cp5_pT(double p, double T) {
    int Ji0[6] = {0, 1, -3, -2, -1, 2};
    double ni0[6] = {-13.179983674201, 6.8540841634434, -0.024805148933466, 0.36901534980333, -3.1161318213925, -0.32961626538917};
    int Iir[5] = {1, 1, 1, 2, 3};
    int Jir[5] = {0, 1, 3, 9, 3};
    double nir[5] = {-1.2563183589592e-04, 2.1774678714571e-03, -0.004594282089991, -3.9724828359569e-06, 1.2919228289784e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double tau = 1000 / T;
    double Pi = p;
    double gamma0_tautau = 0;

    for (int i = 0; i < 6; i++) {
        gamma0_tautau += ni0[i] * Ji0[i] * (Ji0[i] - 1) * pow(tau, Ji0[i] - 2);
    }

    double gammar_tautau = 0;

    for (int i = 0; i < 5; i++) {
        gammar_tautau += nir[i] * pow(Pi, Iir[i]) * Jir[i] * (Jir[i] - 1) * pow(tau, Jir[i] - 2);
    }

    return -R * pow(tau, 2) * (gamma0_tautau + gammar_tautau);
}

double s5_pT(double p, double T) {
    int Ji0[6] = {0, 1, -3, -2, -1, 2};
    double ni0[6] = {-13.179983674201, 6.8540841634434, -0.024805148933466, 0.36901534980333, -3.1161318213925, -0.32961626538917};
    int Iir[5] = {1, 1, 1, 2, 3};
    int Jir[5] = {0, 1, 3, 9, 3};
    double nir[5] = {-1.2563183589592e-04, 2.1774678714571e-03, -0.004594282089991, -3.9724828359569e-06, 1.2919228289784e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double tau = 1000 / T;
    double Pi = p;
    double gamma0 = log(Pi);
    double gamma0_tau = 0;

    for (int i = 0; i < 6; i++) {
        gamma0_tau += ni0[i] * Ji0[i] * pow(tau, Ji0[i] - 1);
        gamma0 += ni0[i] * pow(tau, Ji0[i]);
    }

    double gammar = 0;
    double gammar_tau = 0;

    for (int i = 0; i < 5; i++) {
        gammar += nir[i] * pow(Pi, Iir[i]) * pow(tau, Jir[i]);
        gammar_tau += nir[i] * pow(Pi, Iir[i]) * Jir[i] * pow(tau, Jir[i] - 1);
    }

    return R * (tau * (gamma0_tau + gammar_tau) - (gamma0 + gammar));
}

double Cv5_pT(double p, double T) {
    int Ji0[6] = {0, 1, -3, -2, -1, 2};
    double ni0[6] = {-13.179983674201, 6.8540841634434, -0.024805148933466, 0.36901534980333, -3.1161318213925, -0.32961626538917};
    int Iir[5] = {1, 1, 1, 2, 3};
    int Jir[5] = {0, 1, 3, 9, 3};
    double nir[5] = {-1.2563183589592e-04, 2.1774678714571e-03, -0.004594282089991, -3.9724828359569e-06, 1.2919228289784e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double tau = 1000.0 / T;
    double Pi = p;
    double gamma0_tautau = 0.0;
    int i;

    for (i = 0; i < 6; i++) {
        gamma0_tautau += ni0[i] * (Ji0[i] - 1) * Ji0[i] * pow(tau, Ji0[i] - 2);
    }

    double gammar_pi = 0.0;
    double gammar_pitau = 0.0;
    double gammar_pipi = 0.0;
    double gammar_tautau = 0.0;

    for (i = 0; i < 5; i++) {
        gammar_pi += nir[i] * Iir[i] * pow(Pi, Iir[i] - 1) * pow(tau, Jir[i]);
        gammar_pitau += nir[i] * Iir[i] * pow(Pi, Iir[i] - 1) * Jir[i] * pow(tau, Jir[i] - 1);
        gammar_pipi += nir[i] * Iir[i] * (Iir[i] - 1) * pow(Pi, Iir[i] - 2) * pow(tau, Jir[i]);
        gammar_tautau += nir[i] * pow(Pi, Iir[i]) * Jir[i] * (Jir[i] - 1) * pow(tau, Jir[i] - 2);
    }

    return R * (-(pow(tau, 2) * (gamma0_tautau + gammar_tautau))
                - pow(1 + Pi * gammar_pi - tau * Pi * gammar_pitau, 2)
                / (1 - pow(Pi, 2) * gammar_pipi));
}

double w5_pT(double p, double T) {
    int Ji0[6] = {0, 1, -3, -2, -1, 2};
    double ni0[6] = {-13.179983674201, 6.8540841634434, -0.024805148933466, 0.36901534980333, -3.1161318213925, -0.32961626538917};
    int Iir[5] = {1, 1, 1, 2, 3};
    int Jir[5] = {0, 1, 3, 9, 3};
    double nir[5] = {-1.2563183589592e-04, 2.1774678714571e-03, -0.004594282089991, -3.9724828359569e-06, 1.2919228289784e-07};
    double R = SPECIFIC_GAS_CONSTANT;
    double tau = 1000.0 / T;
    double Pi = p;
    double gamma0_tautau = 0.0;
    int i;

    for (i = 0; i < 6; i++) {
        gamma0_tautau += ni0[i] * (Ji0[i] - 1) * Ji0[i] * pow(tau, Ji0[i] - 2);
    }

    double gammar_pi = 0.0;
    double gammar_pitau = 0.0;
    double gammar_pipi = 0.0;
    double gammar_tautau = 0.0;

    for (i = 0; i < 5; i++) {
        gammar_pi += nir[i] * Iir[i] * pow(Pi, Iir[i] - 1) * pow(tau, Jir[i]);
        gammar_pitau += nir[i] * Iir[i] * pow(Pi, Iir[i] - 1) * Jir[i] * pow(tau, Jir[i] - 1);
        gammar_pipi += nir[i] * Iir[i] * (Iir[i] - 1) * pow(Pi, Iir[i] - 2) * pow(tau, Jir[i]);
        gammar_tautau += nir[i] * pow(Pi, Iir[i]) * Jir[i] * (Jir[i] - 1) * pow(tau, Jir[i] - 2);
    }

    return sqrt(
        1000.0 * R * T * (1 + 2 * Pi * gammar_pi + pow(Pi, 2) * pow(gammar_pi, 2)) /
        ((1 - pow(Pi, 2) * gammar_pipi) +
         pow(1 + Pi * gammar_pi - tau * Pi * gammar_pitau, 2) / (pow(tau, 2) * (gamma0_tautau + gammar_tautau)))
    );
}

double T5_ph(double p, double h) {
    double Ts, Low_Bound = 1073.15;
    double High_Bound = 2273.15;
    double hs = h - 1;
    int step_counter = 0;
    int converged = 0;

    while (fabs(h - hs) > 0.00001) {
        step_counter++;
        double last_hs = hs;

        double Ts = (Low_Bound + High_Bound) / 2;
        hs = h5_pT(p, Ts);  // Assuming you have the implementation of the function h5_pT()

        if (last_hs == hs) {
            printf("T5_ph stopped iterating after %d steps because values did not converge\n", step_counter);
            converged = 1;
            break;
        }

        if (hs > h) {
            High_Bound = Ts;
        } else {
            Low_Bound = Ts;
        }
    }

    if (!converged) {
        printf("T5_ph did not converge after the maximum number of steps\n");
    }

    return Ts;
}

double T5_ps(double p, double s) {
    double Ts, Low_Bound = 1073.15;
    double High_Bound = 2273.15;
    double ss = s - 1;
    int step_counter = 0;
    int converged = 0;

    while (fabs(s - ss) > 0.00001) {
        step_counter++;
        double last_ss = ss;

        double Ts = (Low_Bound + High_Bound) / 2;
        ss = s5_pT(p, Ts);  // Assuming you have the implementation of the function s5_pT()

        if (last_ss == ss) {
            printf("T5_ps stopped iterating after %d steps because values did not converge\n", step_counter);
            converged = 1;
            break;
        }

        if (ss > s) {
            High_Bound = Ts;
        } else {
            Low_Bound = Ts;
        }
    }

    if (!converged) {
        printf("T5_ps did not converge after the maximum number of steps\n");
    }

    return Ts;
}

double T5_prho(double p, double rho) {
    double Ts, Low_Bound = 1073.15;
    double High_Bound = 2073.15;
    double rhos = -1000;
    int step_counter = 0;
    int converged = 0;

    while (fabs(rho - rhos) > 0.000001) {
        step_counter++;
        double last_rhos = rhos;

        double Ts = (Low_Bound + High_Bound) / 2;
        rhos = 1 / v2_pT(p, Ts);  // Assuming you have the implementation of the function v2_pT()

        if (last_rhos == rhos) {
            printf("T5_prho stopped iterating after %d steps because values did not converge\n", step_counter);
            converged = 1;
            break;
        }

        if (rhos < rho) {
            High_Bound = Ts;
        } else {
            Low_Bound = Ts;
        }
    }

    if (!converged) {
        printf("T5_prho did not converge after the maximum number of steps\n");
    }
    return Ts;
}








// Seleccion de Region

int region_pT(double p, double T) {
    if (T > 1073.15 && p < 50.0 && T < 2273.15 && p > 0.000611) {
        return 5;
    } else if (T <= 1073.15 && T > 273.15 && p <= 100 && p > 0.000611) {
        if (T > 623.15) {
            if (p > B23p_T(T)) {
                return 3;
                if (T < 647.096) {
                    double ps = p4_T(T);
                    if (fabs(p - ps) < 0.00001) {
                        return 4;
                    }
                }
            } else {
                return 2;
            }
        } else {
            double ps = p4_T(T);
            if (fabs(p - ps) < 0.00001) {
                return 4;
            } else if (p > ps) {
                return 1;
            } else {
                return 2;
            }
        }
    } else {
        printf("Temperature outside valid area\n");
        return 0; // **Error, Outside valid area
    }
}

int region_ph(double p, double h) {
    if (p < 0.000611657 || p > 100) {
        printf("Pressure outside valid area\n");
        return 0;
    }

    if (h < (0.963 * p + 2.2)) {
        if (h < h1_pT(p, 273.15)) {
            printf("Enthalpy outside valid area\n");
            return 0;
        }
    }

    if (p < 16.5292) {
        double Ts = T4_p(p);
        double hL = 109.6635 * log(p) + 40.3481 * p + 734.58;
        if (fabs(h - hL) < 100) {
            hL = h1_pT(p, Ts);
        }
        if (h <= hL) {
            return 1;
        }

        double hV = 45.1768 * log(p) - 20.158 * p + 2804.4;
        if (fabs(h - hV) < 50) {
            hV = h2_pT(p, Ts);
        }
        if (h < hV) {
            return 4;
        }

        if (h < 4000) {
            return 2;
        }

        double h_45 = h2_pT(p, 1073.15);
        if (h <= h_45) {
            return 2;
        }

        if (p > 10) {
            printf("Pressure outside valid area\n");
            return 0;
        }

        double h_5u = h5_pT(p, 2273.15);
        if (h < h_5u) {
            return 5;
        }

        printf("Enthalpy outside valid area\n");
        return 0;
    } else {
        if (h < h1_pT(p, 623.15)) {
            return 1;
        }

        if (h < h2_pT(p, B23T_p(p))) {
            if (p > p3sat_h(h)) {
                return 3;
            } else {
                return 4;
            }
        }

        if (h < h2_pT(p, 1073.15)) {
            return 2;
        }
    }

    printf("Pressure outside valid area\n");
    return 0;
}

int region_ps(double p, double s) {
    if (p < 0.000611657 || p > 100 || s < 0 || s > s5_pT(p, 2273.15)) {
        printf("Pressure or Entropy outside valid area\n");
        return 0;
    }

    if (s > s2_pT(p, 1073.15)) {
        if (p <= 10) {
            return 5;
        } else {
            printf("Pressure outside valid area\n");
            return 0;
        }
    }

    double ss;
    if (p > 16.529) {
        ss = s2_pT(p, B23T_p(p));
    } else {
        ss = s2_pT(p, T4_p(p));
    }

    if (s > ss) {
        return 2;
    }

    ss = s1_pT(p, 623.15);
    if (p > 16.529 && s > ss) {
        if (p > p3sat_s(s)) {
            return 3;
        } else {
            return 4;
        }
    }

    if (p < 16.529 && s > s1_pT(p, T4_p(p))) {
        return 4;
    }

    if (p > 0.000611657 && s > s1_pT(p, 273.15)) {
        return 1;
    }

    return 1;
}

int region_hs(double h, double s){
    /*function region_hs = region_hs(h, s)

    Section 3.4 Regions as a function of hs
    */
    if (s < -0.0001545495919){
        printf("Entropy outside valid area");
        return 0;
    }
    // Check linear adaption to p=0.000611. if below region 4.
    double hMin = ((-0.0415878 - 2500.89262) / (-0.00015455 - 9.155759)) * s;
    double TMax, hMax, hB, vmax, Tmin, hV, hL, Tact, pact, pBound;

    if ((s < 9.155759395) && (h < hMin)){
        printf("Entalpy or Entropy outside valid area");
        return 0;
    }
    // Kolla 1 eller 4. (+liten bit ???ver B13)
    if ((s >= -0.0001545495919) && (s <= 3.77828134)){
        if (h < h4_s(s)){
            return 4;
        }
        else if (s < 3.397782955){  // 100MPa line is limiting
            TMax = T1_ps(100, s);
            hMax = h1_pT(100, TMax);
            if (h < hMax){
                return 1;
            }
            else{
                printf("Entalpy outside valid area");
                return 0;
            }
        }
        else{  // The point is either in region 4,1,3. Check B23
            hB = hB13_s(s);
            if (h < hB){
                return 1;
            }
            TMax = T3_ps(100, s);
            vmax = v3_ps(100, s);
            hMax = h3_rhoT(1 / vmax, TMax);
            if (h < hMax){
                return 3;
            }
            else{
                printf("Entalpy outside valid area");
                return 0;
            }
        }
    }
    // Kolla region 2 eller 4. (???vre delen av omr???de b23-> max)
    if ((s >= 5.260578707) && (s <= 11.9212156897728)){
        if (s > 9.155759395){ // Above region 4
            Tmin = T2_ps(0.000611, s);
            hMin = h2_pT(0.000611, Tmin);
            // function adapted to h(1073.15,s)
            hMax = (
                -0.07554022 * s*s*s*s
                + 3.341571 * s*s*s
                - 55.42151 * s*s
                + 408.515 * s
                + 3031.338
            );
            if ((h > hMin) && (h < hMax)){
                return 2;
            }
            else{
                printf("Entalpy outside valid area");
                return 0;
            }
        }
        hV = h4_s(s);
        if (h < hV){  // Region 4. Under region 3.
            return 4;
        }
        if (s < 6.04048367171238){
            TMax = T2_ps(100, s);
            hMax = h2_pT(100, TMax);
        }
        else{
            // function adapted to h(1073.15,s)
            hMax = (
                -2.988734 * s*s*s*s
                + 121.4015 * s*s*s
                - 1805.15 * s*s
                + 11720.16 * s
                - 23998.33
            );
        }
        if (h < hMax){  // Region 2. ???ver region 4.
            return 2;
        }
        else{
            printf("Entalpy outside valid area");
            return 0;
        }

    }
    // Kolla region 3 eller 4. Under kritiska punkten.
    if ((s >= 3.77828134) && (s <= 4.41202148223476)){
        hL = h4_s(s);
        if (h < hL){
            return 4;
        }
        TMax = T3_ps(100, s);
        vmax = v3_ps(100, s);
        hMax = h3_rhoT(1 / vmax, TMax);
        if (h < hMax){
            return 3;
        }
        else {
            printf("Entalpy outside valid area");
            return 0;
        }
    }
    // Kolla region 3 eller 4 fr???n kritiska punkten till ???vre delen av b23
    if ((s >= 4.41202148223476) && (s <= 5.260578707)){
        hV = h4_s(s);
        if (h < hV){
            return 4;
        }
        // Kolla om vi ???r under b23 giltighetsomr???de.
        if (s <= 5.048096828){
            TMax = T3_ps(100, s);
            vmax = v3_ps(100, s);
            hMax = h3_rhoT(1 / vmax, TMax);
            if (h < hMax){
                return 3;
            }
            else{
                printf("Entalpy outside valid area");
                return 0;
            }
        }
        else{  // Inom omr???det f???r B23 i s led.
            if (h > 2812.942061){  // Ovanf???r B23 i h_led
                if (s > 5.09796573397125){
                    TMax = T2_ps(100, s);
                    hMax = h2_pT(100, TMax);
                    if (h < hMax){
                        return 2;
                    }
                    else{
                        printf("Entalpy outside valid area");
                        return 0;
                    }
                }
                else {
                    printf("Entropy outside valid area");
                    return 0;
                }
            }
            if (h < 2563.592004){  // Nedanf???r B23 i h_led men vi har redan kollat ovanf???r hV2c3b
                return 3;
            }
            // Vi ???r inom b23 omr???det i b???de s och h led.
            Tact = TB23_hs(h, s);
            pact = p2_hs(h, s);
            pBound = B23p_T(Tact);
            if (pact > pBound){
                return 3;
            }
            else{
                return 2;
            }
        }
    }
    printf("Entropy and Entalpy outside valid area");
    return 0;
}

int region_prho(double p, double rho) {
    double v = 1 / rho;
    if (p < 0.000611657 || p > 100) {
        printf("Pressure outside valid area\n");
        return 0;
    }
    if (p < 16.5292) {
        if (v < v1_pT(p, 273.15)) {
            printf("Specific volume outside valid area\n");
            return 0;
        }
        if (v <= v1_pT(p, T4_p(p))) {
            return 1;
        }
        if (v < v2_pT(p, T4_p(p))) {
            return 4;
        }
        if (v <= v2_pT(p, 1073.15)) {
            return 2;
        }
        if (p > 10) {
            printf("Pressure outside valid area\n");
            return 0;
        }
        if (v <= v5_pT(p, 2073.15)) {
            return 5;
        }
    } else {
        if (v < v1_pT(p, 273.15)) {
            printf("Specific volume outside valid area\n");
            return 0;
        }
        if (v < v1_pT(p, 623.15)) {
            return 1;
        }
        if (v < v2_pT(p, B23T_p(p))) {
            if (p > 22.064) {
                return 3;
            }
            if (v < v3_ph(p, h4L_p(p)) || v > v3_ph(p, h4V_p(p))) {
                return 3;
            } else {
                return 4;
            }
        }
        if (v < v2_pT(p, 1073.15)) {
            return 2;
        }
    }
    printf("Pressure and Density outside valid area\n");
    return 0;
}




// Aqui va lo correspondiente a Transport Properties

double my_AllRegions_pT(double p, double T) {
    double h0[] = {0.5132047, 0.3205656, 0, 0, -0.7782567, 0.1885447};
    double h1[] = {0.2151778, 0.7317883, 1.241044, 1.476783, 0, 0};
    double h2[] = {-0.2818107, -1.070786, -1.263184, 0, 0, 0};
    double h3[] = {0.1778064, 0.460504, 0.2340379, -0.4924179, 0, 0};
    double h4[] = {-0.0417661, 0, 0, 0.1600435, 0, 0};
    double h5[] = {0, -0.01578386, 0, 0, 0, 0};
    double h6[] = {0, 0, 0, -0.003629481, 0, 0};

    double rho, rhos, Ts, temp_sum, my0, my1, mys;

    // Calculate density.
    int region = region_pT(p, T);
    if (region == 1) {
        rho = 1 / v1_pT(p, T);
    } else if (region == 2) {
        rho = 1 / v2_pT(p, T);
    } else if (region == 3) {
        double hs = h3_pT(p, T);
        rho = 1 / v3_ph(p, hs);
    } else if (region == 4) {
        printf("function my_AllRegions_pT is not available in region 4\n");
        return NAN;
    } else if (region == 5) {
        rho = 1 / v5_pT(p, T);
    } else {
        printf("Region switch returned unknown value\n");
        return NAN;
    }

    rhos = rho / 317.763;
    Ts = T / 647.226;

    // Check valid area
    if ((T > (900 + 273.15)) ||
        ((T > (600 + 273.15)) && (p > 300)) ||
        ((T > (150 + 273.15)) && (p > 350)) ||
        (p > 500)) {
        printf("Temperature and/or Pressure out of range of validity\n");
        return NAN;
    }

    my0 = sqrt(Ts) / (1 + 0.978197 / Ts + 0.579829 / (Ts * Ts) - 0.202354 / (Ts * Ts * Ts));
    temp_sum = 0;
    for (int i = 0; i < 6; i++) {
        temp_sum += h0[i] * pow(((1 / Ts) - 1), i)
                    + h1[i] * pow(((1 / Ts) - 1), i) * pow((rhos - 1), 1)
                    + h2[i] * pow(((1 / Ts) - 1), i) * pow((rhos - 1), 2)
                    + h3[i] * pow(((1 / Ts) - 1), i) * pow((rhos - 1), 3)
                    + h4[i] * pow(((1 / Ts) - 1), i) * pow((rhos - 1), 4)
                    + h5[i] * pow(((1 / Ts) - 1), i) * pow((rhos - 1), 5)
                    + h6[i] * pow(((1 / Ts) - 1), i) * pow((rhos - 1), 6);
    }
    my1 = exp(rhos * temp_sum);
    mys = my0 * my1;
    return mys * 0.000055071;
}


double my_AllRegions_ph(double p, double h) {
    double h0[6] = {0.5132047, 0.3205656, 0, 0, -0.7782567, 0.1885447};
    double h1[6] = {0.2151778, 0.7317883, 1.241044, 1.476783, 0, 0};
    double h2[6] = {-0.2818107, -1.070786, -1.263184, 0, 0, 0};
    double h3[6] = {0.1778064, 0.460504, 0.2340379, -0.4924179, 0, 0};
    double h4[6] = {-0.0417661, 0, 0, 0.1600435, 0, 0};
    double h5[6] = {0, -0.01578386, 0, 0, 0, 0};
    double h6[6] = {0, 0, 0, -0.003629481, 0, 0};

    double Ts, T, rho, my0, my1, mys;

    // Calculate density.
    int region = region_ph(p, h);
    if (region == 1) {
        Ts = T1_ph(p, h);
        T = Ts;
        rho = 1 / v1_pT(p, Ts);
    } else if (region == 2) {
        Ts = T2_ph(p, h);
        T = Ts;
        rho = 1 / v2_pT(p, Ts);
    } else if (region == 3) {
        rho = 1 / v3_ph(p, h);
        T = T3_ph(p, h);
    } else if (region == 4) {
        double xs = x4_ph(p, h);
        double v4v, v4L;
        if (p < 16.529) {
            v4v = v2_pT(p, T4_p(p));
            v4L = v1_pT(p, T4_p(p));
        } else {
            v4v = v3_ph(p, h4V_p(p));
            v4L = v3_ph(p, h4L_p(p));
        }
        rho = 1 / (xs * v4v + (1 - xs) * v4L);
        T = T4_p(p);
    } else if (region == 5) {
        Ts = T5_ph(p, h);
        T = Ts;
        rho = 1 / v5_pT(p, Ts);
    } else {
        printf("Region switch returned unknown value\n");
        return NAN;
    }

    double rhos = rho / 317.763;
    Ts = T / 647.226;
    if (
    (T > (900 + 273.15))
    || (T > (600 + 273.15) && (p > 300))
    || (T > (150 + 273.15) && (p > 350))
    || (p > 500)) {
        printf("Temperature and/or Pressure out of range of validity\n");
        return NAN;
    }
    my0 = sqrt(Ts) / (1 + 0.978197 / Ts + 0.579829 / pow(Ts, 2) - 0.202354 / pow(Ts, 3));
    double temp_sum = 0;
    for (int i = 0; i < 6; i++) {
        temp_sum +=
            h0[i] * pow(1 / Ts - 1, i)
            + h1[i] * pow(1 / Ts - 1, i) * pow(rhos - 1, 1)
            + h2[i] * pow(1 / Ts - 1, i) * pow(rhos - 1, 2)
            + h3[i] * pow(1 / Ts - 1, i) * pow(rhos - 1, 3)
            + h4[i] * pow(1 / Ts - 1, i) * pow(rhos - 1, 4)
            + h5[i] * pow(1 / Ts - 1, i) * pow(rhos - 1, 5)
            + h6[i] * pow(1 / Ts - 1, i) * pow(rhos - 1, 6);
    }
    my1 = exp(rhos * temp_sum);
    mys = my0 * my1;
    return mys * 0.000055071;
}

double tc_ptrho(float p, float T, float rho) {
    if (T < 273.15) {
        printf("Temperature out of range of validity\n");
        return NAN;
    } else if (T < 500 + 273.15) {
        if (p > 100) {
            printf("Pressure out of range of validity\n");
            return NAN;
        }
    } else if (T <= 650 + 273.15) {
        if (p > 70) {
            printf("Pressure out of range of validity\n");
            return NAN;
        }
    } else {
        if (p > 40) {
            printf("Pressure out of range of validity\n");
            return NAN;
        }
    }

    T = T / 647.26;
    rho = rho / 317.7;

    double tc0 = sqrt(T) * (0.0102811 + 0.0299621 * T + 0.0156146 * pow(T, 2) - 0.00422464 * pow(T, 3));

    double tc1 = -0.397070 + 0.400302 * rho + 1.06 * exp(-0.171587 * pow((rho + 2.392190), 2));

    double dT = fabs(T - 1) + 0.00308976;
    double Q = 2 + 0.0822994 / pow(dT, 3.0 / 5.0);
    double s;
    if (T >= 1) {
        s = 1 / dT;
    } else {
        s = 10.0932 / pow(dT, 3.0 / 5.0);
    }

    double tc2 = (0.0701309 / pow(T, 10) + 0.0118520) * pow(rho, 9.0 / 5.0) * exp(0.642857 * (1 - pow(rho, 14.0 / 5.0)))
                + 0.00169937 * s * pow(rho, Q) * exp((Q / (1 + Q)) * (1 - pow(rho, 1 + Q)))
                - 1.02 * exp(-4.11717 * pow(T, 3.0 / 2.0) - 6.17937 / pow(rho, 5));

    return tc0 + tc1 + tc2;
}

double Surface_Tension_T(double T) {
    double tc = CRITICAL_TEMPERATURE;
    double B = 0.2358;  // N/m
    double bb = -0.625;
    double my = 1.256;
    if (T < 0.01 || T > tc) {
        printf("Temperature out of range of validity\n");
        return NAN;
    }

    double tau = 1 - T / tc;
    return B * pow(tau, my) * (1 + bb * tau);
}


// Aqui lo del propio XSteam

double tsat_p(double p) {
    if (p > 0.000611657 && p < 22.06395) {
        return T4_p(p);
    } else {
        printf("pressure %f MPa out of range\n", p);
        return NAN;
    }
}

double tsat_s(double s) {
    if (s > -0.0001545495919 && s < 9.155759395) {
        double ps = p4_s(s);
        return T4_p(ps);
    } else {
        printf("entropy value %f KJ/(Kg K) is out of range\n", s);
        return NAN;
    }
}

double t_ph(double p, double h) {
    int region = region_ph(p, h);
    if (region == 1) {
        return T1_ph(p, h);
    } else if (region == 2) {
        return T2_ph(p, h);
    } else if (region == 3) {
        return T3_ph(p, h);
    } else if (region == 4) {
        return T4_p(p);
    } else if (region == 5) {
        return T5_ph(p, h);
    } else {
        printf("Region switch t_ph returned unknown value %d for input p %f and h %f\n", region, p, h);
        return NAN;
    }
}

double t_ps(double p, double s) {
    int region = region_ps(p, s);
    if (region == 1) {
        return T1_ps(p, s);
    } else if (region == 2) {
        return T2_ps(p, s);
    } else if (region == 3) {
        return T3_ps(p, s);
    } else if (region == 4) {
        return T4_p(p);
    } else if (region == 5) {
        return T5_ps(p, s);
    } else {
        printf("Region switch t_ps returned unknown value %d for input p %f and s %f\n", region, p, s);
        return NAN;
    }
}

double t_hs(double h, double s) {
    int region = region_hs(h, s);
    if (region == 1) {
        double p1 = p1_hs(h, s);
        return T1_ph(p1, h);
    } else if (region == 2) {
        double p2 = p2_hs(h, s);
        return T2_ph(p2, h);
    } else if (region == 3) {
        double p3 = p3_hs(h, s);
        return T3_ph(p3, h);
    } else if (region == 4) {
        return T4_hs(h, s);
    } else if (region == 5) {
        printf("functions t_hs is not available in region 5 for input h %f and s %f\n", h, s);
        return NAN;
    } else {
        printf("Region switch t_hs returned unknown value %d for input h %f and s %f\n", region, h, s);
        return NAN;
    }
}

double psat_s(double s) {
    if (s > -0.0001545495919 && s < 9.155759395) {
        return p4_s(s);
    } else {
        printf("entropy value %f out of range\n", s);
        return NAN;
    }
}

double psat_t(double t) {
    if (t < 647.096 && t > 273.1) {
        double T = t;
        return p4_T(T);
    } else {
        printf("temperature %f out of range\n", t);
        return NAN;
    }
}

double p_hs(double h, double s) {
    int region = region_hs(h, s);
    if (region == 1) {
        return p1_hs(h, s);
    } else if (region == 2) {
        return p2_hs(h, s);
    } else if (region == 3) {
        return p3_hs(h, s);
    } else if (region == 4) {
        double tSat = T4_hs(h, s);
        return p4_T(tSat);
    } else if (region == 5) {
        printf("functions p_hs is not available in region 5 for input h %f and s %f\n", h, s);
        return NAN;
    } else {
        printf("Region switch p_hs returned unknown value for input h %f and s %f\n", h, s);
        return NAN;
    }
}

double p_hrho(double h, double rho) {
    if (rho <= 0.0) {
        printf("negative values for density rho not allowed %f\n", rho);
        // Puedes elegir lanzar una excepción en lugar de imprimir un mensaje de error
        // throw std::invalid_argument("rho out of range");
        return NAN;
    }

    double High_Bound = 100.0;
    double Low_Bound = 0.000611657;
    double ps = (High_Bound+Low_Bound)/2;
    double rhos = rho_ph(ps, h);

    int step_counter = 0;
    while (fabs(rho - rhos) > 0.0000001) {
        step_counter++;
        double last_rhos = rhos;

        rhos = 1.0 / v_ph(ps, h);

        if (step_counter == 100) {
            printf("p_hrho stopped iterating after %d steps because values did not converge for input values h %f and rho %f\n", step_counter, h, rho);
            break;
        }

        if (rhos >= rho) {
            High_Bound = ps;
        } else {
            Low_Bound = ps;
        }
        ps = (Low_Bound + High_Bound) / 2.0;
    }
    return ps;
}

double hV_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        double hV = h4V_p(p);
        return hV;
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double hL_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        double hL = h4L_p(p);
        return hL;
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double hV_t(double t) {
    if ((t > 273.15) && (t < 647.096)) {
        double p = p4_T(t);
        double hV = h4V_p(p);
        return hV;
    } else {
        printf("temperature %f out of range\n", t);
        return NAN;
    }
}

double hL_t(double t) {
    if ((t > 273.15) && (t < 647.096)) {
        double p = p4_T(t);
        double hL = h4L_p(p);
        return hL;
    } else {
        printf("temperature %f out of range\n", t);
        return NAN;
    }
}

double h_pt(double p, double t) {
    double T = t;
    int region = region_pT(p, T);
    if (region == 1) {
        double h = h1_pT(p, T);
        return h;
    } else if (region == 2) {
        double h = h2_pT(p, T);
        return h;
    } else if (region == 3) {
        double h = h3_pT(p, T);
        return h;
    } else if (region == 4) {
        printf("function h_pt is not available in region 4 for input p %f and T %f\n", p, T);
        return NAN;
    } else if (region == 5) {
        double h = h5_pT(p, T);
        return h;
    } else {
        printf("Region switch h_pt returned unknown value %d for input p %f and T %f\n", region, p, T);
        return NAN;
    }
}

double h_ps(double p, double s) {
    int region = region_ps(p, s);
    if (region == 1) {
        double T = T1_ps(p, s);
        double h = h1_pT(p, T);
        return h;
    } else if (region == 2) {
        double T = T2_ps(p, s);
        double h = h2_pT(p, T);
        return h;
    } else if (region == 3) {
        double v = 1 / v3_ps(p, s);
        double T = T3_ps(p, s);
        double h = h3_rhoT(v, T);
        return h;
    } else if (region == 4) {
        double xs = x4_ps(p, s);
        double hV = h4V_p(p);
        double hL = h4L_p(p);
        double h = xs * hV + (1 - xs) * hL;
        return h;
    } else if (region == 5) {
        double T = T5_ps(p, s);
        double h = h5_pT(p, T);
        return h;
    } else {
        printf("Region switch h_ps returned unknown value %d for input p %f and s %f\n", region, p, s);
        return NAN;
    }
}

double h_px(double p, double x) {
    if (x > 1 || x < 0 || p >= 22.064) {
        printf("Vapor fraction %f and/or pressure %f out of range\n", x, p);
        return NAN;
    }
    double hL = h4L_p(p);
    double hV = h4V_p(p);
    double h = hL + x * (hV - hL);
    return h;
}

double h_prho(double p, double rho) {
    int region = region_prho(p, rho);
    if (region == 1) {
        double T = T1_prho(p, rho);
        double h = h1_pT(p, T);
        return h;
    } else if (region == 2) {
        double T = T2_prho(p, rho);
        double h = h2_pT(p, T);
        return h;
    } else if (region == 3) {
        double T = T3_prho(p, rho);
        double h = h3_rhoT(rho, T);
        return h;
    } else if (region == 4) {
        double vV, vL, hV, hL, x;
        if (p < 16.529) {
            vV = v2_pT(p, T4_p(p));
            vL = v1_pT(p, T4_p(p));
        } else {
            vV = v3_ph(p, h4V_p(p));
            vL = v3_ph(p, h4L_p(p));
        }
        hV = h4V_p(p);
        hL = h4L_p(p);
        x = (1 / rho - vL) / (vV - vL);
        double h = (1 - x) * hL + x * hV;
        return h;
    } else if (region == 5) {
        double T = T5_prho(p, rho);
        double h = h5_pT(p, T);
        return h;
    } else {
        printf("Region switch h_prho returned unknown value %d for input p %f and rho %f\n", region, p, rho);
        return NAN;
    }
}

double h_tx(double t, double x) {
    double T = t;
    if (x > 1 || x < 0 || T >= 647.096) {
        printf("Vapor fraction %f and/or temperature %f out of range\n", x, T);
        return NAN;
    }
    double p = p4_T(T);
    double hL = h4L_p(p);
    double hV = h4V_p(p);
    double h = hL + x * (hV - hL);
    return h;
}

double vV_p(double p) {
    if (p > 0.000611657 && p < 22.06395) {
        if (p < 16.529) {
            double v = v2_pT(p, T4_p(p));
            return v;
        } else {
            double v = v3_ph(p, h4V_p(p));
            return v;
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double vL_p(double p) {
    if (p > 0.000611657 && p < 22.06395) {
        if (p < 16.529) {
            double v = v1_pT(p, T4_p(p));
            return v;
        } else {
            double v = v3_ph(p, h4L_p(p));
            return v;
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double vV_t(double t) {
    double T = t;
    if (T > 273.15 && T < 647.096) {
        if (T <= 623.15) {
            double v = v2_pT(p4_T(T), T);
            return v;
        } else {
            double v = v3_ph(p4_T(T), h4V_p(p4_T(T)));
            return v;
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double vL_t(double t) {
    double T = t;
    if (T > 273.15 && T < 647.096) {
        if (T <= 623.15) {
            double v = v1_pT(p4_T(T), T);
            return v;
        } else {
            double v = v3_ph(p4_T(T), h4L_p(p4_T(T)));
            return v;
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double v_pt(double p, double t) {
    double T = t;
    int region = region_pT(p, T);
    if (region == 1) {
        double v = v1_pT(p, T);
        return v;
    } else if (region == 2) {
        double v = v2_pT(p, T);
        return v;
    } else if (region == 3) {
        double h = h3_pT(p, T);
        double v = v3_ph(p, h);
        return v;
    } else if (region == 4) {
        printf("function v_pt is not available in region 4 for input p %f and T %f\n", p, T);
        return NAN;
    } else if (region == 5) {
        double v = v5_pT(p, T);
        return v;
    } else {
        printf("Region switch v_pt returned unknown value %d for input p %f and T %f\n", region, p, T);
        return NAN;
    }
}

double v_ph(double p, double h) {
    int region = region_ph(p, h);
    if (region == 1) {
        double T = T1_ph(p, h);
        double v = v1_pT(p, T);
        return v;
    } else if (region == 2) {
        double T = T2_ph(p, h);
        double v = v2_pT(p, T);
        return v;
    } else if (region == 3) {
        double v = v3_ph(p, h);
        return v;
    } else if (region == 4) {
        double xs = x4_ph(p, h);
        double v4v, v4L;
        if (p < 16.529) {
            v4v = v2_pT(p, T4_p(p));
            v4L = v1_pT(p, T4_p(p));
        } else {
            v4v = v3_ph(p, h4V_p(p));
            v4L = v3_ph(p, h4L_p(p));
        }
        double v = xs * v4v + (1 - xs) * v4L;
        return v;
    } else if (region == 5) {
        double Ts = T5_ph(p, h);
        double v = v5_pT(p, Ts);
        return v;
    } else {
        printf("Region switch v_ph returned unknown value %d for input p %f and h %f\n", region, p, h);
        return NAN;
    }
}

double v_ps(double p, double s) {
    int region = region_ps(p, s);
    if (region == 1) {
        double T = T1_ps(p, s);
        double v = v1_pT(p, T);
        return v;
    } else if (region == 2) {
        double T = T2_ps(p, s);
        double v = v2_pT(p, T);
        return v;
    } else if (region == 3) {
        double v = v3_ps(p, s);
        return v;
    } else if (region == 4) {
        double xs = x4_ps(p, s);
        double v4v, v4L;
        if (p < 16.529) {
            v4v = v2_pT(p, T4_p(p));
            v4L = v1_pT(p, T4_p(p));
        } else {
            v4v = v3_ph(p, h4V_p(p));
            v4L = v3_ph(p, h4L_p(p));
        }
        double v = xs * v4v + (1 - xs) * v4L;
        return v;
    } else if (region == 5) {
        double Ts = T5_ps(p, s);
        double v = v5_pT(p, Ts);
        return v;
    } else {
        printf("Region switch v_ps returned unknown value %d for input p %f and s %f\n", region, p, s);
        return NAN;
    }
}

double rhoV_p(double p) {
    double v = vV_p(p);
    double rhoV = 1 / v;
    return rhoV;
}

double rhoL_p(double p) {
    double v = vL_p(p);
    double rhoL = 1 / v;
    return rhoL;
}

double rhoV_t(double t) {
    double v = vV_t(t);
    double rhoV = 1 / v;
    return rhoV;
}

double rhoL_t(double t) {
    double v = vL_t(t);
    double rhoL = 1 / v;
    return rhoL;
}

double rho_pt(double p, double t) {
    double v = v_pt(p, t);
    double rho = 1 / v;
    return rho;
}

double rho_ph(double p, double h) {
    double v = v_ph(p, h);
    double rho = 1 / v;
    return rho;
}

double rho_ps(double p, double s) {
    double v = v_ps(p, s);
    double rho = 1 / v;
    return rho;
}

double sV_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return s2_pT(p, T4_p(p));

        }
        else {
            double v = 1 / v3_ph(p, h4V_p(p));
            return s3_rhoT(v, T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double sL_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return s1_pT(p, T4_p(p));
        } else {
            double v = 1 / v3_ph(p, h4L_p(p));
            return s3_rhoT(v, T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double sV_t(double t) {
    double T = t;  // No se requiere conversión ya que la función acepta la temperatura en las unidades correctas
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return s2_pT(p4_T(T), T);
        } else {
            double v = 1 / v3_ph(p4_T(T), h4V_p(p4_T(T)));
            return s3_rhoT(v, T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}


double sL_t(double t) {
    double T = t;  // No se requiere conversión ya que la función acepta la temperatura en las unidades correctas
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return s1_pT(p4_T(T), T);
        } else {
            double v = 1 / v3_ph(p4_T(T), h4L_p(p4_T(T)));
            return s3_rhoT(v, T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double s_pt(double p, double t) {
    double P = p;  // No se requiere conversión ya que la función acepta la presión en las unidades correctas
    double T = t;  // No se requiere conversión ya que la función acepta la temperatura en las unidades correctas
    int region = region_pT(P, T);
    if (region == 1) {
        return s1_pT(P, T);
    } else if (region == 2) {
        return s2_pT(P, T);
    } else if (region == 3) {
        double hs = h3_pT(P, T);
        double rhos = 1 / v3_ph(P, hs);
        return s3_rhoT(rhos, T);
    } else if (region == 4) {
        printf("function s_pt is not available in region 4 (p %f, T %f)\n", P, T);
        return NAN;
    } else if (region == 5) {
        return s5_pT(P, T);
    } else {
        printf("Region switch s_pt returned unknown value %d for input p %f and T %f\n", region, P, T);
        return NAN;
    }
}

double s_ph(double p, double h) {
    double region = region_ph(p, h);
    if (region == 1) {
        double T = T1_ph(p, h);
        return s1_pT(p, T);
    } else if (region == 2) {
        double T = T2_ph(p, h);
        return s2_pT(p, T);
    } else if (region == 3) {
        double rhos = 1 / v3_ph(p, h);
        double Ts = T3_ph(p, h);
        return s3_rhoT(rhos, Ts);
    } else if (region == 4) {
        double Ts = T4_p(p);
        double xs = x4_ph(p, h);
        if (p < 16.529) {
            double s4v = s2_pT(p, Ts);
            double s4L = s1_pT(p, Ts);
            return xs * s4v + (1 - xs) * s4L;
        } else {
            double v4v = v3_ph(p, h4V_p(p));
            double s4v = s3_rhoT(1 / v4v, Ts);
            double v4L = v3_ph(p, h4L_p(p));
            double s4L = s3_rhoT(1 / v4L, Ts);
            return xs * s4v + (1 - xs) * s4L;
        }
    } else if (region == 5) {
        double T = T5_ph(p, h);
        return s5_pT(p, T);
    } else {
        printf("Region switch s_ph returned unknown value %d for input p %f and h %f\n", region, p, h);
        return NAN;
    }
}

double uV_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return u2_pT(p, T4_p(p));
        } else {
            double v = 1 / v3_ph(p, h4V_p(p));
            return u3_rhoT(v, T4_p(p));
        }
    } else {
        return NAN;
    }
}

double uL_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return u1_pT(p, T4_p(p));
        } else {
            double v = 1 / v3_ph(p, h4L_p(p));
            return u3_rhoT(v, T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double uV_t(double t) {
    double T = t;  // No se requiere conversión ya que la función acepta la temperatura en las unidades correctas
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return u2_pT(p4_T(T), T);
        } else {
            double v = 1 / v3_ph(p4_T(T), h4V_p(p4_T(T)));
            return u3_rhoT(v, T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double uL_t(double t) {
    double T = t;
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return u1_pT(p4_T(T), T);
        } else {
            double v = 1 / v3_ph(p4_T(T), h4L_p(p4_T(T)));
            return u3_rhoT(v, T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double u_pt(double p, double t) {
    int region = region_pT(p, t);
    if (region == 1) {
        return u1_pT(p, t);
    } else if (region == 2) {
        return u2_pT(p, t);
    } else if (region == 3) {
        double hs = h3_pT(p, t);
        double rhos = 1 / v3_ph(p, hs);
        return u3_rhoT(rhos, t);
    } else if (region == 4) {
        printf("function u_pt is not available in region 4 for input p %f and T %f\n", p, t);
        return NAN;
    } else if (region == 5) {
        return u5_pT(p, t);
    } else {
        printf("Region switch u_pt returned unknown value %d for input p %f and T %f\n", region, p, t);
        return NAN;
    }
}

double u_ph(double p, double h) {
    int region = region_ph(p, h);
    if (region == 1) {
        double Ts = T1_ph(p, h);
        return u1_pT(p, Ts);
    } else if (region == 2) {
        double Ts = T2_ph(p, h);
        return u2_pT(p, Ts);
    } else if (region == 3) {
        double rhos = 1 / v3_ph(p, h);
        double Ts = T3_ph(p, h);
        return u3_rhoT(rhos, Ts);
    } else if (region == 4) {
        double Ts = T4_p(p);
        double xs = x4_ph(p, h);
        double u4v, u4L;
        if (p < 16.529) {
            u4v = u2_pT(p, Ts);
            u4L = u1_pT(p, Ts);
        } else {
            double v4v = v3_ph(p, h4V_p(p));
            u4v = u3_rhoT(1 / v4v, Ts);
            double v4L = v3_ph(p, h4L_p(p));
            u4L = u3_rhoT(1 / v4L, Ts);
        }
        return xs * u4v + (1 - xs) * u4L;
    } else if (region == 5) {
        double Ts = T5_ph(p, h);
        return u5_pT(p, Ts);
    } else {
        printf("Region switch u_ph returned unknown value %d for input p %f and h %f\n", region, p, h);
        return NAN;
    }
}

double u_ps(double p, double s) {
    int region = region_ps(p, s);
    if (region == 1) {
        double Ts = T1_ps(p, s);
        return u1_pT(p, Ts);
    } else if (region == 2) {
        double Ts = T2_ps(p, s);
        return u2_pT(p, Ts);
    } else if (region == 3) {
        double rhos = 1 / v3_ps(p, s);
        double Ts = T3_ps(p, s);
        return u3_rhoT(rhos, Ts);
    } else if (region == 4) {
        double Ts = T4_p(p);
        double uLp, uVp;
        if (p < 16.529) {
            uLp = u1_pT(p, Ts);
            uVp = u2_pT(p, Ts);
        } else {
            uLp = u3_rhoT(1 / v3_ph(p, h4L_p(p)), Ts);
            uVp = u3_rhoT(1 / v3_ph(p, h4V_p(p)), Ts);
        }
        double xs = x4_ps(p, s);
        return xs * uVp + (1 - xs) * uLp;
    } else if (region == 5) {
        double Ts = T5_ps(p, s);
        return u5_pT(p, Ts);
    } else {
        printf("Region switch u_ps returned unknown value %d for input p %f and s %f\n", region, p, s);
        return NAN;
    }
}

double CpV_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return Cp2_pT(p, T4_p(p));
        } else {
            return Cp3_rhoT(1 / (v3_ph(p, h4V_p(p))), T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double CpL_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return Cp1_pT(p, T4_p(p));
        } else {
            return Cp3_rhoT(1 / (v3_ph(p, h4L_p(p))), T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double CpV_t(double t) {
    double T = t;
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return Cp2_pT(p4_T(T), T);
        } else {
            return Cp3_rhoT(1 / (v3_ph(p4_T(T), h4V_p(p4_T(T)))), T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double CpL_t(double t) {
    double T = t;
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return Cp1_pT(p4_T(T), T);
        } else {
            return Cp3_rhoT(1 / (v3_ph(p4_T(T), h4L_p(p4_T(T)))), T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double Cp_pt(double p, double t) {
    double T = t;
    int region = region_pT(p, T);
    if (region == 1) {
        return Cp1_pT(p, T);
    } else if (region == 2) {
        return Cp2_pT(p, T);
    } else if (region == 3) {
        double hs = h3_pT(p, T);
        double rhos = 1 / v3_ph(p, hs);
        return Cp3_rhoT(rhos, T);
    } else if (region == 4) {
        printf("function Cp_pt is not available in region 4 for input p %f and T %f\n", p, T);
        return NAN;
    } else if (region == 5) {
        return Cp5_pT(p, T);
    } else {
        printf("Region switch Cp_pt returned unknown value %d for input p %f and T %f\n", region, p, T);
        return NAN;
    }
}

double Cp_ph(double p, double h) {
    int region = region_ph(p, h);
    if (region == 1) {
        double Ts = T1_ph(p, h);
        return Cp1_pT(p, Ts);
    } else if (region == 2) {
        double Ts = T2_ph(p, h);
        return Cp2_pT(p, Ts);
    } else if (region == 3) {
        double rhos = 1 / v3_ph(p, h);
        double Ts = T3_ph(p, h);
        return Cp3_rhoT(rhos, Ts);
    } else if (region == 4) {
        printf("function Cp_ph is not available in region 4 for input p %f and h %f\n", p, h);
        return NAN;
    } else if (region == 5) {
        double Ts = T5_ph(p, h);
        return Cp5_pT(p, Ts);
    } else {
        printf("Region switch Cp_ph returned unknown value %d for input p %f and h %f\n", region, p, h);
        return NAN;
    }
}

double Cp_ps(double p, double s) {
    int region = region_ps(p, s);
    if (region == 1) {
        double Ts = T1_ps(p, s);
        return Cp1_pT(p, Ts);
    } else if (region == 2) {
        double Ts = T2_ps(p, s);
        return Cp2_pT(p, Ts);
    } else if (region == 3) {
        double rhos = 1 / v3_ps(p, s);
        double Ts = T3_ps(p, s);
        return Cp3_rhoT(rhos, Ts);
    } else if (region == 4) {
        printf("function Cp_ps is not available in region 4 for input p %f and s %f\n", p, s);
        return NAN;
    } else if (region == 5) {
        double Ts = T5_ps(p, s);
        return Cp5_pT(p, Ts);
    } else {
        printf("Region switch Cp_ps returned unknown value %d for input p %f and s %f\n", region, p, s);
        return NAN;
    }
}

double CvV_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return Cv2_pT(p, T4_p(p));
        } else {
            return Cv3_rhoT(1 / v3_ph(p, h4V_p(p)), T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double CvL_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return Cv1_pT(p, T4_p(p));
        } else {
            return Cv3_rhoT(1 / v3_ph(p, h4L_p(p)), T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double CvV_t(double t) {
    double T = t;
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return Cv2_pT(p4_T(T), T);
        } else {
            return Cv3_rhoT(1 / v3_ph(p4_T(T), h4V_p(p4_T(T))), T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double CvL_t(double t) {
    double T = t;
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return Cv1_pT(p4_T(T), T);
        } else {
            return Cv3_rhoT(1 / v3_ph(p4_T(T), h4L_p(p4_T(T))), T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double Cv_pt(double p, double t) {
    double T = t;
    int region = region_pT(p, T);
    if (region == 1) {
        return Cv1_pT(p, T);
    } else if (region == 2) {
        return Cv2_pT(p, T);
    } else if (region == 3) {
        double hs = h3_pT(p, T);
        double rhos = 1 / v3_ph(p, hs);
        return Cv3_rhoT(rhos, T);
    } else if (region == 4) {
        printf("function Cv_pt is not available in region 4 for input p %f and T %f\n", p, T);
        return NAN;
    } else if (region == 5) {
        return Cv5_pT(p, T);
    } else {
        printf("Region switch Cv_pt returned unknown value %d for input p %f and T %f\n", region, p, T);
        return NAN;
    }
}

double Cv_ph(double p, double h) {
    int region = region_ph(p, h);
    if (region == 1) {
        double Ts = T1_ph(p, h);
        return Cv1_pT(p, Ts);
    } else if (region == 2) {
        double Ts = T2_ph(p, h);
        return Cv2_pT(p, Ts);
    } else if (region == 3) {
        double rhos = 1 / v3_ph(p, h);
        double Ts = T3_ph(p, h);
        return Cv3_rhoT(rhos, Ts);
    } else if (region == 4) {
        printf("function Cv_ph is not available in region 4 for input p %f and h %f\n", p, h);
        return NAN;
    } else if (region == 5) {
        double Ts = T5_ph(p, h);
        return Cv5_pT(p, Ts);
    } else {
        printf("Region switch Cv_ph returned unknown value %d for input p %f and h %f\n", region, p, h);
        return NAN;
    }
}

double Cv_ps(double p, double s) {
    int region = region_ps(p, s);
    if (region == 1) {
        double Ts = T1_ps(p, s);
        return Cv1_pT(p, Ts);
    } else if (region == 2) {
        double Ts = T2_ps(p, s);
        return Cv2_pT(p, Ts);
    } else if (region == 3) {
        double rhos = 1 / v3_ps(p, s);
        double Ts = T3_ps(p, s);
        return Cv3_rhoT(rhos, Ts);
    } else if (region == 4) {
        printf("function Cv_ps is not available in region 4 for input p %f and s %f\n", p, s);
        return NAN;
    } else if (region == 5) {
        double Ts = T5_ps(p, s);
        return Cv5_pT(p, Ts);
    } else {
        printf("Region switch Cv_ps returned unknown value %d for input p %f and s %f\n", region, p, s);
        return NAN;
    }
}

double wV_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return w2_pT(p, T4_p(p));
        } else {
            return w3_rhoT(1 / v3_ph(p, h4V_p(p)), T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double wL_p(double p) {
    if ((p > 0.000611657) && (p < 22.06395)) {
        if (p < 16.529) {
            return w1_pT(p, T4_p(p));
        } else {
            return w3_rhoT(1 / v3_ph(p, h4L_p(p)), T4_p(p));
        }
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double wV_t(double t) {
    double T = t;
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return w2_pT(p4_T(T), T);
        } else {
            return w3_rhoT(1 / v3_ph(p4_T(T), h4V_p(p4_T(T))), T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double wL_t(double t) {
    double T = t;
    if ((T > 273.15) && (T < 647.096)) {
        if (T <= 623.15) {
            return w1_pT(p4_T(T), T);
        } else {
            return w3_rhoT(1 / v3_ph(p4_T(T), h4L_p(p4_T(T))), T);
        }
    } else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}

double w_pt(double p, double t) {
    double T = t;
    int region = region_pT(p, T);
    if (region == 1) {
        return w1_pT(p, T);
    } else if (region == 2) {
        return w2_pT(p, T);
    } else if (region == 3) {
        double hs = h3_pT(p, T);
        double rhos = 1 / v3_ph(p, hs);
        return w3_rhoT(rhos, T);
    } else if (region == 4) {
        printf("function w_pt is not available in region 4 for input p %f and T %f\n", p, T);
        return NAN;
    } else if (region == 5) {
        return w5_pT(p, T);
    } else {
        printf("Region switch w_pt returned unknown value %d for input p %f and T %f\n", region, p, T);
        return NAN;
    }
}

double w_ph(double p, double h) {
    int region = region_ph(p, h);
    if (region == 1) {
        double Ts = T1_ph(p, h);
        return w1_pT(p, Ts);
    } else if (region == 2) {
        double Ts = T2_ph(p, h);
        return w2_pT(p, Ts);
    } else if (region == 3) {
        double rhos = 1 / v3_ph(p, h);
        double Ts = T3_ph(p, h);
        return w3_rhoT(rhos, Ts);
    } else if (region == 4) {
        printf("function w_ph is not available in region 4 p %f and h %f\n", p, h);
        return NAN;
    } else if (region == 5) {
        double Ts = T5_ph(p, h);
        return w5_pT(p, Ts);
    } else {
        printf("Region switch w_ph returned unknown value %d for input p %f and h %f\n", region, p, h);
        return NAN;
    }
}

double w_ps(double p, double s) {
    int region = region_ps(p, s);
    if (region == 1) {
        double Ts = T1_ps(p, s);
        return w1_pT(p, Ts);
    } else if (region == 2) {
        double Ts = T2_ps(p, s);
        return w2_pT(p, Ts);
    } else if (region == 3) {
        double rhos = 1 / v3_ps(p, s);
        double Ts = T3_ps(p, s);
        return w3_rhoT(rhos, Ts);
    } else if (region == 4) {
        printf("function w_ps is not available in region 4 for input p %f and s %f\n", p, s);
        return NAN;
    } else if (region == 5) {
        double Ts = T5_ps(p, s);
        return w5_pT(p, Ts);
    } else {
        printf("Region switch w_ps returned unknown value %d for input p %f and s %f\n", region, p, s);
        return NAN;
    }
}

double my_pt(double p, double t) {
    int region = region_pT(p, t);
    if (region == 4) {
        printf("function my_pt is not available in region 4 for input p %f and T %f\n", p, t);
        return NAN;
    } else if (region == 1 || region == 2 || region == 3 || region == 5) {
        return my_AllRegions_pT(p, t);
    } else {
        printf("Region switch my_pt returned unknown value %d for input p %f and T %f\n", region, p, t);
        return NAN;
    }
}

double my_ph(double p, double h) {
    int region = region_ph(p, h);
    if (region == 1 || region == 2 || region == 3 || region == 5) {
        return my_AllRegions_ph(p, h);
    } else if (region == 4) {
        printf("function my_pt is not available in region 4 for input p %f and h %f\n", p, h);
        return NAN;
    } else {
        printf("Region switch my_ph returned unknown value %d for input p %f and h %f\n", region, p, h);
        return NAN;
    }
}

double my_ps(double p, double s) {
    double h = h_ps(p, s);
    return my_ph(p, h);
}

double pr_pt(double p, double t) {
    double Cp = Cp_pt(p, t);
    double my = my_pt(p, t);
    double tc = tc_pt(p, t);
    return Cp * 1000 * my / tc;
}

double pr_ph(double p, double h) {
    double Cp = Cp_ph(p, h);
    double my = my_ph(p, h);
    double tc = tc_ph(p, h);
    return Cp * 1000 * my / tc;
}

double st_t(double t) {
    double T = t;
    return Surface_Tension_T(T);
}

double st_p(double p) {
    double T = tsat_p(p);
    T = T;
    return Surface_Tension_T(T);
}

double tcL_p(double p) {
    double t = tsat_p(p);
    double v = vL_p(p);
    double rho = 1.0 / v;
    return tc_ptrho(p, t, rho);
}

double tcV_p(double p) {
    double ps = p;
    double T = tsat_p(p);
    double v = vV_p(ps);
    double rho = 1.0 / v;
    return tc_ptrho(p, T, rho);
}

double tcL_t(double t) {
    double Ts = t;
    double p = psat_t(Ts);
    double v = vL_t(Ts);
    double rho = 1 / v;
    return tc_ptrho(p, Ts, rho);
}

double tcV_t(double t) {
    double Ts = t;
    double p = psat_t(Ts);
    double v = vV_t(Ts);
    double rho = 1 / v;
    return tc_ptrho(p, Ts, rho);
}

double tc_pt(double p, double t) {
    double Ts = t;
    double ps = p;
    double v = v_pt(ps, Ts);
    double rho = 1 / v;
    return tc_ptrho(p, Ts, rho);
}

double tc_ph(double p, double h) {
    double hs = h;
    double ps = p;
    double v = v_ph(ps, hs);
    double T = t_ph(ps, hs);
    double rho = 1 / v;
    return tc_ptrho(p, T, rho);
}

double tc_hs(double h, double s) {
    double hs = h;
    double p = p_hs(hs, s);
    double ps = p;
    double v = v_ph(ps, hs);
    double T = t_ph(ps, hs);
    double rho = 1 / v;
    return tc_ptrho(p, T, rho);
}

double x_ph(double p, double h) {
    if (p > 0.000611657 && p < 22.06395) {
        return x4_ph(p, h);
    } else {
        printf("pressure out of range\n");
        return NAN;
    }
}

double x_ps(double p, double s) {
    if (p > 0.000611657 && p < 22.06395) {
        return x4_ps(p, s);
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double vx_ph(double p, double h) {
    if (p > 0.000611657 && p < 22.06395) {
        double vL, vV;
        if (p < 16.529) {
            vL = v1_pT(p, T4_p(p));
            vV = v2_pT(p, T4_p(p));
        } else {
            vL = v3_ph(p, h4L_p(p));
            vV = v3_ph(p, h4V_p(p));
        }
        double xs = x4_ph(p, h);
        return xs * vV / (xs * vV + (1 - xs) * vL);
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}

double vx_ps(double p, double s) {
    if (p > 0.000611657 && p < 22.06395) {
        double vL, vV;
        if (p < 16.529) {
            vL = v1_pT(p, T4_p(p));
            vV = v2_pT(p, T4_p(p));
        } else {
            vL = v3_ph(p, h4L_p(p));
            vV = v3_ph(p, h4V_p(p));
        }
        double xs = x4_ps(p, s);
        return xs * vV / (xs * vV + (1 - xs) * vL);
    } else {
        printf("pressure %f out of range\n", p);
        return NAN;
    }
}


double pmelt_t(double t, int hint) {
    double T = t;

    if (hint == -1) {
        if (T >= 251.165 && T < 256.164) {
            printf("can't select ice type based on temperature %f, hint required\n", T);
            return NAN;
        }
        else if (T >= 256.164 && T < 273.31) {
            printf("chose ice type V based on temperature\n");
            return pmelt_T_iceV(T);
        }
        else if (T >= 273.31 && T < 355) {
            printf("chose ice type VI based on temperature\n");
            return pmelt_T_iceVI(T);
        }
        else if (T >= 355 && T < 751) {
            printf("chose ice type VII based on temperature\n");
            return pmelt_T_iceVII(T);
        }
        else {
            printf("temperature %f out of range\n", T);
            return NAN;
        }
    }
    else if (hint == TYPE_ICE_Ih) {
        if (T >= 251.165 && T < 273.16) {
            return pmelt_T_iceIh(T);
        }
        else {
            printf("temperature %f out of range\n", T);
            return NAN;
        }
    }
    else if (hint == TYPE_ICE_III) {
        if (T >= 251.165 && T < 256.164) {
            return pmelt_T_iceIII(T);
        }
        else {
            printf("temperature %f out of range\n", T);
            return NAN;
        }
    }
    else if (hint == TYPE_ICE_V) {
        if (T >= 256.164 && T < 273.31) {
            return pmelt_T_iceV(T);
        }
        else {
            printf("temperature %f out of range\n", T);
            return NAN;
        }
    }
    else if (hint == TYPE_ICE_VI) {
        if (T >= 273.31 && T < 355) {
            return pmelt_T_iceVI(T);
        }
        else {
            printf("temperature %f out of range\n", T);
            return NAN;
        }
    }
    else if (hint == TYPE_ICE_VII) {
        if (T >= 355 && T < 751) {
            return pmelt_T_iceVII(T);
        }
        else {
            printf("temperature %f out of range\n", T);
            return NAN;
        }
    }
    else {
        printf("unknown value for parameter 'hint' %d, can't select ice type\n", hint);
        return NAN;
    }
}

double psubl_t(double t) {
    double T = t;

    if (T >= 50 && T < 273.16) {
        return psubl_T(T);
    }
    else {
        printf("temperature %f out of range\n", T);
        return NAN;
    }
}
